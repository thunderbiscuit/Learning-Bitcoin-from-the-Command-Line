<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Bitcoin from the Command Line</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_0_Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_1_Introducing_Bitcoin.html"><strong aria-hidden="true">1.1.</strong> Introducing Bitcoin</a></li></ol></li><li class="chapter-item expanded "><a href="02_0_Setting_Up_a_Bitcoin-Core_VPS.html"><strong aria-hidden="true">2.</strong> Setting Up a Bitcoin Core VPS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_1_Setting_Up_a_Bitcoin-Core_VPS_with_StackScript.html"><strong aria-hidden="true">2.1.</strong> With Bitcoin Standup</a></li><li class="chapter-item expanded "><a href="02_2_Setting_Up_Bitcoin_Core_Other.html"><strong aria-hidden="true">2.2.</strong> Via Other Means</a></li></ol></li><li class="chapter-item expanded "><a href="03_0_Understanding_Your_Bitcoin_Setup.html"><strong aria-hidden="true">3.</strong> Understanding your Bitcoin Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03_1_Verifying_Your_Bitcoin_Setup.html"><strong aria-hidden="true">3.1.</strong> Verifying your Bitcoin Setup</a></li><li class="chapter-item expanded "><a href="03_2_Knowing_Your_Bitcoin_Setup.html"><strong aria-hidden="true">3.2.</strong> Knowing your Bitcoin Setup</a></li><li class="chapter-item expanded "><a href="03_3__Interlude_Using_Command-Line_Variables.html"><strong aria-hidden="true">3.3.</strong> Interlude: Using Command-Line Variables</a></li><li class="chapter-item expanded "><a href="03_3_Setting_Up_Your_Wallet.html"><strong aria-hidden="true">3.4.</strong> Setting Up Your Wallet</a></li><li class="chapter-item expanded "><a href="03_4_Receiving_a_Transaction.html"><strong aria-hidden="true">3.5.</strong> Receiving a Transaction</a></li><li class="chapter-item expanded "><a href="03_5_Understanding_the_Descriptor.html"><strong aria-hidden="true">3.6.</strong> Understanding the Descriptor</a></li></ol></li><li class="chapter-item expanded "><a href="04_0_Sending_Bitcoin_Transactions.html"><strong aria-hidden="true">4.</strong> Sending Bitcoin Transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04_1_Sending_Coins_The_Easy_Way.html"><strong aria-hidden="true">4.1.</strong> Sending Coins the Easy Way</a></li><li class="chapter-item expanded "><a href="04_2__Interlude_Using_JQ.html"><strong aria-hidden="true">4.2.</strong> Interlude: Using JQ</a></li><li class="chapter-item expanded "><a href="04_2_Creating_a_Raw_Transaction.html"><strong aria-hidden="true">4.3.</strong> Creating a Raw Transaction</a></li><li class="chapter-item expanded "><a href="04_3_Creating_a_Raw_Transaction_with_Named_Arguments.html"><strong aria-hidden="true">4.4.</strong> Creating a Raw Transaction With Named Arguments</a></li><li class="chapter-item expanded "><a href="04_4__Interlude_Using_Curl.html"><strong aria-hidden="true">4.5.</strong> Interlude: Using Curl</a></li><li class="chapter-item expanded "><a href="04_4_Sending_Coins_with_a_Raw_Transaction.html"><strong aria-hidden="true">4.6.</strong> Sending Coins with Raw Transactions</a></li><li class="chapter-item expanded "><a href="04_5_Sending_Coins_with_Automated_Raw_Transactions.html"><strong aria-hidden="true">4.7.</strong> Sending Coins with Automated Raw Transactions</a></li><li class="chapter-item expanded "><a href="04_6_Creating_a_Segwit_Transaction.html"><strong aria-hidden="true">4.8.</strong> Creating a Segwit Transaction</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Bitcoin from the Command Line</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-one-introduction-to-learning-bitcoin-core--lightning-from-the-command-line"><a class="header" href="#chapter-one-introduction-to-learning-bitcoin-core--lightning-from-the-command-line">Chapter One: Introduction to Learning Bitcoin Core (&amp; Lightning) from the Command Line</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The ways that we make payments for goods and services has been changing dramatically over the last several decades. Where once all transactions were conducted through cash or checks, now various electronic payment methods are the norm. However, most of these electronic payments still occur through centralized systems, where credit card companies, banks, or even internet-based financial institutions like Paypal keep long, individually correlated lists of transactions and have the power to censor transactions that they don't like.</p>
<p>These centralization risks were some of the prime catalysts behind the creation of cryptocurrencies, the first and most successful of which is Bitcoin. Bitcoin offers pseudonymity; it makes it difficult to correlate transactions; and it makes censorship by individual entities all but impossible. These advantages have made it one of the quickest growing currencies in the world. That growth in turn has made Bitcoin into a going concern among entrepreneurs and developers, eager to create new services for the Bitcoin community.</p>
<p>If you're one of those entrepreneurs or developers, then this course is for you, because it's all about learning to program Bitcoin. It's an introductory course that explains all the nuances and features of Bitcoin as it goes. It also takes a very specific tack, by offering lessons in how to work <em>directly</em> with Bitcoin Core and with the c-lightning server using their RPC interfaces.</p>
<p>Why not use some of the more fully featured libraries found in various programming languages? Why not create your own from scratch? It's because working with cryptocurrency is dangerous. There are no safety nets. If you accidentally overpay your fees or lose a signing key or create an invalid transaction or make any number of potential mistakes, then your cryptocurrency will be gone forever. Much of that responsibility will, of course, lie with you as a cryptocurrency programmer, but it can be minimized by working with the most robust, secure, and safe cryptocurrency interfaces around, the ones created by the cryptocurrency programming teams themselves: <code>bitcoind</code> and <code>lightningd</code>.</p>
<p>Much of this book thus discusses how to script Bitcoin (and Lightning) directly from the command line. Some later chapters deal with more sophisticated programming languages, but again they continue to interact directly with the <code>bitcoind</code> and <code>lightningd</code> daemons by using RPC or by interacting with the files they create. This allows you to stand on the shoulders of giants and use their trusted technology to learn how to create your own trusted systems.</p>
<h2 id="required-skill-level"><a class="header" href="#required-skill-level">Required Skill Level</a></h2>
<p>You do not need to be particularly technical for the majority of this course. All you need is the confidence to run basic commands on the UNIX command line. If you're familiar with things like <code>ssh</code>, <code>cd</code>, and <code>ls</code>, the course will supply you with the rest.</p>
<p>A minority of this course requires programming knowledge, and you should skip over those sections if needed, as discussed in the next section. </p>
<h2 id="overview-of-topics"><a class="header" href="#overview-of-topics">Overview of Topics</a></h2>
<p>This book is broadly divided into the following sections:</p>
<table><thead><tr><th>Part</th><th>Description</th><th>Skills</th></tr></thead><tbody>
<tr><td><strong>Part One: Preparing for Bitcoin</strong></td><td>Understanding the basics of Bitcoin and setting up a server for use.</td><td>Command Line</td></tr>
<tr><td><strong>Part Two: Using Bitcoin-CLI</strong></td><td>Using the Bitcoin-CLI for creating transactions.</td><td>Command Line</td></tr>
<tr><td><strong>Part Three: Bitcoin Scripting</strong></td><td>Expanding your Bitcoin work with scripts.</td><td>Programming Concepts</td></tr>
<tr><td><strong>Part Four: Using Tor</strong></td><td>Improving your node security with Tor</td><td>Command Line</td></tr>
<tr><td><strong>Part Five: Programming with RPC</strong></td><td>Accessing RPC from C and other languages.</td><td>Programming in C</td></tr>
<tr><td><strong>Part Six: Using Lightning-CLI</strong></td><td>Using the Lightning-CLI for creating transactions.</td><td>Command Line</td></tr>
<tr><td><strong>Appendices</strong></td><td>Utilizing less common Bitcoin setups.</td><td>Command Line</td></tr>
</tbody></table>
<h2 id="how-to-use-this-course"><a class="header" href="#how-to-use-this-course">How To Use This Course</a></h2>
<p>So where do you start? This book is primarily intended to be read sequentially. Just follow the &quot;What's Next?&quot; Links at the end of each section and/or click through the individual section links on each chapter page. You'll achieve the best understanding from this course if you actually build yourself a Bitcoin server (per Chapter 2) and then run through all the examples over the course of the book: trying out examples is an excellent learning methodology.</p>
<p>If you have different levels of skill or want to learn different things, you might skip to different parts of the book:</p>
<ul>
<li>If you've already got a Bitcoin environment ready to be used, jump to <a href="03_0_Understanding_Your_Bitcoin_Setup.html">Chapter Three: Understanding Your Bitcoin Setup</a>.</li>
<li>If you only care about Bitcoin scripting, jump to <a href="09_0_Introducing_Bitcoin_Scripts.html">Chapter Nine: Introducing Bitcoin Scripts</a>.</li>
<li>If you just want to read about using programming languages, jump to <a href="16_0_Talking_to_Bitcoind.html">Chapter Sixteen: Talking to Bitcoin</a>.</li>
<li>If you conversely don't want to do any programming, definitely skip chapters 15-17 while you're reading, and perhaps skip chapters 9-13. The rest of the course should still make sense without them.</li>
<li>If you are only interested in Lightning, zap over to <a href="19_0_Understanding_Your_Lightning_Setup.html">Chapter Nineteen: Understanding Your Lightning Setup</a>.</li>
<li>If you want to read the major new content added for v2 of the course (2020), following on v1 (2017), read <a href="03_5_Understanding_the_Descriptor.html">§3.5: Understanding the Descriptor</a>, <a href="04_6_Creating_a_Segwit_Transaction.html">§4.6: Creating a SegWit Transaction</a>, <a href="07_0_Expanding_Bitcoin_Transactions_PSBTs.html">Chapter 7: Expanding Bitcoin with PSBTs</a>, <a href="09_5_Scripting_a_P2WPKH.html">§9.5: Scripting a P2WPKH</a>, <a href="10_5_Scripting_a_Segwit_Script.html">§10.5: Scripting a SegWit Script</a>, <a href="14_0_Using_Tor.html">Chapter 14: Using Tor</a>, <a href="15_0_Using_i2p.html">Chapter 15: Using i2p</a>, <a href="16_0_Talking_to_Bitcoind.html">Chapter 16: Talking to Bitcoind with C</a>, <a href="17_0_Programming_with_Libwally.html">Chapter 17: Programming with Libwally</a>, <a href="18_0_Talking_to_Bitcoind_Other.html">Chapter 18: Talking to Bitcoind with Other Languages</a>, <a href="19_0_Understanding_Your_Lightning_Setup.html">Chapter 19: Understanding Your Lighting Setup</a>, and <a href="20_0_Using_Lightning.html">Chapter 20: Using Lightning</a>.</li>
</ul>
<h2 id="why-to-use-this-course"><a class="header" href="#why-to-use-this-course">Why to Use this Course</a></h2>
<p>Obviously, you're working through this course because you're interested in Bitcoin. Besides imparting basic knowledge, it's also helped readers to join (or create) open-source projects and to get entry-level jobs in Bitcoin programming. A number of Blockchain Commons' interns learned about Bitcoin from this course, as have some members of our programming team.</p>
<h2 id="how-to-support-this-course"><a class="header" href="#how-to-support-this-course">How to Support this Course</a></h2>
<ul>
<li>Please use <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/issues">Issues</a> for any questions. Blockchain Commons does not have an active support team, and so we can't address individual problems or queries, but we will look over them in time, and use them to improve future iterations of the course.</li>
<li>Please use <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/pulls">PRs</a> for any fixes of typos or incorrect (or changed) commands. For command-line or technical changes, it's very helpful if you also use the PR comments to explain why you did what you did, so that we don't have to research it.</li>
<li>Please Use Our <a href="https://github.com/BlockchainCommons/Community/discussions">Community discussions area</a> for talking about careers and skills. Blockchain Commons occasionally offers internships, as discussed in our Community repo.</li>
<li>Please <a href="https://github.com/sponsors/BlockchainCommons">become a patron</a> if you find this course helpful or if you want to help educate the next generation of blockchain programmers.</li>
</ul>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>If you'd like a basic introduction to Bitcoin, public-key cryptography, ECC, blockchains, and Lightning, read the <a href="01_1_Introducing_Bitcoin.html">Introducing Bitcoin</a> interlude. </p>
<p>Otherwise, if you're ready to dive into the course, go to <a href="02_0_Setting_Up_a_Bitcoin-Core_VPS.html">Setting Up a Bitcoin-Core VPS</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-introducing-bitcoin"><a class="header" href="#interlude-introducing-bitcoin">Interlude: Introducing Bitcoin</a></h1>
<p>Before you can get started programming Bitcoin (and Lightning), you should have a basic understanding of what they are and how they work. This section provides that overview. Many more definitions will appear within the document itself; this is only intended to lay the foundation.</p>
<h2 id="about-bitcoin"><a class="header" href="#about-bitcoin">About Bitcoin</a></h2>
<p>Bitcoin is a programmatic system that allows for the transfer of the bitcoin currency. It is enabled by a decentralized, peer-to-peer system of nodes, which include full nodes, wallets, and miners. Working together, they ensure that bitcoin transactions are fast and non-repudiable. Thanks to the decentralized nature of the system, these transactions are also censor-resistant and can provide other advantages such as pseudonymity and non-correlation if used well.</p>
<p>Obviously, Bitcoin is the heart of this book, but it's also the originator of many other systems, including blockchains and Lightning, which are both detailed in this tutorial, and many other cryptocurrencies such as Ethereum and Litecoin, which are not.</p>
<p><strong><em>How Are Coins Transferred?</em></strong> Bitcoin currency isn't physical coins. Instead it's an endless series of ownership reassignments. When one person sends coins to another, that transfer is stored as a transaction. It's the transaction that actually records the ownership of the money, not any token local to the owner's wallet or their machine.</p>
<p><strong><em>Who Can You Send Coins To?</em></strong> The vast majority of bitcoin transactions involve coins being sent to individual people (or at least to individual Bitcoin addresses). However, more complex methodologies can be used to send bitcoins to groups of people or to scripts. These various methodologies have names like P2PKH, multisig, and P2SH.</p>
<p><strong><em>How Are Transactions Stored?</em></strong> Transactions are combined into larger blocks of data, which are then written to the blockchain ledger. A block is built in such a way that it cannot be replaced or rewritten once several blocks have been built atop (following) it. This is what makes bitcoins non-repudiable: the decentralized global ledger where everything is recorded is effectively a permanent and unchangeable database.</p>
<p>However, the process of building these blocks is stochastic: it's somewhat random, so you can never be assured that a transaction will be placed in a specific block. There can also be changes in blocks if they're very recent, but only if they're <em>very</em> recent. So, things become non-repudiable (and permanent and unchangeable) after a little bit of time.</p>
<p><strong><em>How Are Transactions Protected?</em></strong> The funds contained in a Bitcoin transaction are locked with a cryptographic puzzle. These puzzles are designed so that they can be easily solved by the person who the funds were sent to. This is done using the power of public-key cryptography. Technically, a transaction is protected by a signature that proves you're the owner of the public key that a transaction was sent to: this proof of ownership is the puzzle that's being solved.</p>
<p>Funds are further protected by the use of hashes. Public keys aren't actually stored in the blockchain until the funds are spent: only public-key hashes are. This means that even if quantum computer were to come along, Bitcoin transactions would remain protected by this second level of cryptography.</p>
<p><strong><em>How Are Transactions Created?</em></strong> The heart of each Bitcoin transaction is a FORTH-like scripting language that is used to lock the transaction. To respend the money, the recipient provides specific information to the script that proves he's the intended recipient.</p>
<p>However, these Bitcoin scripts are the lowest level of Bitcoin functionality. Much Bitcoin work is done through the <code>bitcoind</code> Bitcoin daemon, which is controlled through RPC commands. Many people send those RPC commands through the <code>bitcoin-cli</code> program, which provides an even simpler interface. Non-programmers don't even worry about these minutia, but instead use programmed wallets with simpler interfaces.</p>
<h3 id="bitcoin--in-short"><a class="header" href="#bitcoin--in-short">Bitcoin — In Short</a></h3>
<p>One way to think of Bitcoin is as <em>a sequence of atomic transactions</em>. Each transaction is authenticated by a sender with the solution to a previous cryptographic puzzle that was stored as a script. The new transaction is locked for the recipient with a new cryptographic puzzle that is also stored as a script. Every transaction is recorded in an immutable global ledger.</p>
<h2 id="about-public-key-cryptography"><a class="header" href="#about-public-key-cryptography">About Public-Key Cryptography</a></h2>
<p>Public-key cryptography is a mathematical system for protecting data and proving ownership through an asymmetric pair of linked keys: the public key and the private key.</p>
<p>It's important to Bitcoin (and to most blockchain systems) because it's the basis of a lot of the cryptography that protects the cryptocurrency funds. A Bitcoin transaction is typically sent to an address that is a hashed public key. The recipient is then able to retrieve the money by revealing both the public key and the private key.</p>
<p><strong><em>What Is a Public Key?</em></strong> A public key is the key given out to other people. In a typical public-key system, a user generates a public key and a private key, then he gives the public key to all and sundry. Those recipients can encrypt information with the public key, but it can't be decrypted with the same public key because of the asymmetry of the key pair.</p>
<p><strong><em>What Is a Private Key?</em></strong> A private key is linked to a public key in a key pair. In a typical public-key system, a user keeps his private key secure and uses it to decrypt messages that were encrypted with his public key before being sent to him.</p>
<p><strong><em>What Is a Signature?</em></strong> A message (or more commonly, a hash of a message) can be signed with a private key, creating a signature. Anyone with the corresponding public key can then validate the signature, which verifies that the signer owns the private key associated with the public key in question. <em>SegWit</em> is a specific format for storing a signature on the Bitcoin network that we'll meet down the line.</p>
<p><strong><em>What Is a Hash Function?</em></strong> A hash function is an algorithm frequently used with cryptography. It's a way to map a large, arbitrary amount of data to a small, fixed amount of data. Hash functions used in cryptography are one-way and collision-resistant, meaning that a hash can reliably be linked to the original data, but the original data can not be regenerated from the hash. Hashes thus allow the transmission of small amounts of data to represent large amounts of data, which can be important for efficiency and storage requirements.</p>
<p>Bitcoin takes advantage of a hash's ability to disguise the original data, which allows concealment of a user's actual public key, making transactions resistant to quantum computing.</p>
<h3 id="public-key-cryptography--in-short"><a class="header" href="#public-key-cryptography--in-short">Public-Key Cryptography — In Short</a></h3>
<p>One way to think of public-key cryptography is: <em>a way for anyone to protect data such that only an authorized person can access it, and such that the authorized person can prove that he will have that access.</em></p>
<h2 id="about-ecc"><a class="header" href="#about-ecc">About ECC</a></h2>
<p>ECC stands for elliptic-curve cryptography. It's a specific branch of public-key cryptography that depends on mathematical calculations conducted using elliptic curves defined over finite fields. It's more complex and harder to explain than classic public-key cryptography (which used prime numbers), but it has some nice advantages.</p>
<p>ECC does not receive much attention in this tutorial. That's because this tutorial is all about integrating with Bitcoin Core and Lightning servers, which have already taken care of the cryptography for you. In fact, this tutorial's intention is that you don't have to worry about cryptography at all, because that's something that you <em>really</em> want experts to deal with.</p>
<p><strong><em>What is an Elliptic Curve?</em></strong> An elliptic curve is a geometric curve that takes the form <code>y</code><sup><code>2</code></sup> = <code>x</code><sup><code>3</code></sup><code> + ax + b</code>. A specific elliptic curve is chosen by selecting specific values of <code>a</code> and <code>b</code>. The curve must then be carefully examined to determine if it works well for cryptography. For example, the secp256k1 curve used by Bitcoin is defined as <code>a=0</code> and <code>b=7</code>.</p>
<p>Any line that intersects an elliptic curve will do so at either 1 or 3 points ... and that's the basis of elliptic-curve cryptography.</p>
<p><strong><em>What are Finite Fields?</em></strong> A finite field is a finite set of numbers, where all addition, subtraction, multiplication, and division is defined so that it results in other numbers also in the same finite field. One simple way to create a finite field is through the use of a modulo function.</p>
<p><strong><em>How is an Elliptic Curve Defined Over a Finite Field?</em></strong> An elliptic curve defined over a finite field has all of the points on its curve drawn from a specific finite field. This takes the form: <code>y</code><sup><code>2</code></sup> <code>% field-size = (x</code><sup><code>3</code></sup><code> + ax + b) % field-size</code> The finite field used for secp256k1 is <code>2</code><sup><code>256</code></sup><code> - 2</code><sup><code>32</code></sup><code> - 2</code><sup><code>9</code></sup><code> - 2</code><sup><code>8</code></sup><code> - 2</code><sup><code>7</code></sup><code> - 2</code><sup><code>6</code></sup><code> - 2</code><sup><code>4</code></sup><code> - 1</code>.</p>
<p><strong><em>How Are Elliptic Curves Used in Cryptography?</em></strong> In elliptic-curve cryptography, a user selects a very large (256-bit) number as his private key. He then adds a set base point on the curve to itself that many times. (In secp256k1, the base point is <code>G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</code>, which prefixes the two parts of the tuple with an <code>04</code> to say that the data point is in uncompressed form. If you prefer a straight geometric definition, it's the point &quot;0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8&quot;) The resultant number is the public key. Various mathematical formula can then be used to prove ownership of the public key, given the private key. As with any cryptographic function, this one is a trap door: it's easy to go from private key to public key and largely impossible to go from public key to private key.</p>
<p>This particular methodology also explains why finite fields are used in elliptic curves: it ensures that the private key will not grow too large. Note that the finite field for secp256k1 is slightly smaller than 256 bits, which means that all public keys will be 256 bits long, just like the private keys are.</p>
<p><strong><em>What Are the Advantages of ECC?</em></strong> The main advantage of ECC is that it allows the same security as classic public-key cryptography with a much smaller key. A 256-bit elliptic-curve public key corresponds to a 3072-bit traditional (RSA) public key.</p>
<h3 id="ecc---in-short"><a class="header" href="#ecc---in-short">ECC - In Short</a></h3>
<p>One way to think of ECC is: <em>a way to enable public-key cryptography that uses very small keys and very obscure math.</em></p>
<h2 id="about-blockchains"><a class="header" href="#about-blockchains">About Blockchains</a></h2>
<p>Blockchain is the generalization of the methodology used by Bitcoin to create a distributed global ledger. Bitcoin is a blockchain as are any number of alt-coins, each of which lives on its own network and writes to its own chain. Sidechains like Liquid are blockchains too. Blockchains don't even need to have anything to do with finances. For example, there have been many discussions of using blockchains to protect self-sovereign identities.</p>
<p>Though you need to understand the basics of how a blockchain works to understand how transactions work in Bitcoin, you won't need to go any further than that. Because blockchains have become a wide category of technology, those basic concepts are likely to be applicable to many other projects in this growing technology sector. The specific programming commands learned in this book will not be, however, as they're fairly specific to Bitcoin (and Lightning).</p>
<p><strong><em>Why Is It Called a Chain?</em></strong> Each block in the blockchain stores a hash of the block before it. This links the current block all the way back to the original &quot;genesis block&quot; through an unbroken chain. It's a way to create absolute order among possibly conflicting data. This also provides the security of blockchain, because each block is stacked atop an old one makes it harder to recreate the old block due to the proof-of-work algorithms used in block creation. Once several blocks have been built atop a block in the chain, it's essentially irreversible.</p>
<p><strong><em>What is a Fork?</em></strong> Occasionally two blocks are created around the same time. This temporarily creates a one-block fork, where either if the current blocks could be the &quot;real&quot; one. Every once in a while, a fork might expand to become two blocks, three blocks, or even four blocks long, but pretty quickly one side of the fork is determined to be the real one, and the other is &quot;orphaned&quot;. This is part of the stochastic process of block creation, and demonstrates why several blocks must be built atop a block before it can be considered truly trustworthy and non-repudiable.</p>
<h3 id="blockchain--in-short"><a class="header" href="#blockchain--in-short">Blockchain — In Short</a></h3>
<p>One way to think of blockchain is: <em>a linked series of blocks of unchangeable data, going back in time</em>. Another way is: <em>a linked series of blocks to absolutely order data that could be conflicting</em>.</p>
<h2 id="is-blockchain-right-for-me"><a class="header" href="#is-blockchain-right-for-me">Is Blockchain Right for Me?</a></h2>
<p>If you want to transact bitcoins, then obviously Bitcoin is right for you. However, more widely, blockchain has become a popular buzz-word even though it's not a magic bullet for all technical problems. With that said, there are many specific situations where blockchain is a superior technology.</p>
<p>Blockchains probably <em>will</em> be helpful if:</p>
<ul>
<li>Users don't trust each other.
<ul>
<li>Or: Users exist across various borders.</li>
</ul>
</li>
<li>Users don't trust central authorities.
<ul>
<li>And: Users want to control their own destinies.</li>
</ul>
</li>
<li>Users want transparent technology.</li>
<li>Users want to share something.
<ul>
<li>And: Users want what's shared to be permanently recorded.</li>
</ul>
</li>
<li>Users want fast transaction finality.
<ul>
<li>But: Users don't need instant transaction finality.</li>
</ul>
</li>
</ul>
<p>Blockchains probably <em>will not</em> be helpful if:</p>
<ul>
<li>Users are trusted:
<ul>
<li>e.g.: transactions occur within a business or organization.</li>
<li>e.g.: transactions are overseen by a central authority.</li>
</ul>
</li>
<li>Secrecy is required:
<ul>
<li>e.g.: Information should be secret.</li>
<li>e.g.: Transactions should be secret.</li>
<li>e.g.: Transactors should be secret.</li>
<li>Unless: A methodology for cryptographic secrecy is carefully considered, analyzed, and tested.</li>
</ul>
</li>
<li>Users need instant transaction finality.
<ul>
<li>e.g.: in less than 10 minutes on a Bitcoin-like network, in less than 2.5 minutes on a Litecoin-like network, in less than 15 seconds on an Ethereum-like network</li>
</ul>
</li>
</ul>
<p>Do note that there may still be solutions for some of these situations within the Bitcoin ecosystem. For example, payment channels are rapidly addressing questions of liquidity and payment finality.</p>
<h2 id="about-lightning"><a class="header" href="#about-lightning">About Lightning</a></h2>
<p>Lightning is a layer-2 protocol that interacts with Bitcoin to allow users to exchange their bitcoins &quot;off-chain&quot;. It has both advantages and disadvantages over using Bitcoin on its own.</p>
<p>Lightning is also the secondary focus of this tutorial. Though it's mostly about interacting directly with Bitcoin (and the <code>bitcoind</code>), it pays some attention to Lightning because it's an upcoming technology that is likely to become a popular alternative to Bitcoin in the near future. This book takes the same approach to Lightning as to Bitcoin: it teaches how to interact directly with a trusted Lightning daemon from the command line.</p>
<p>Unlike with Bitcoin, there are actually several variants of Lightning. This tutorial uses the standard-compliant <a href="https://github.com/ElementsProject/lightning">c-lightning</a> implementation as its trusted Lightning server.</p>
<p><strong><em>What is a Layer-2 Protocol?</em></strong> A layer-2 Bitcoin protocol works on top of Bitcoin. In this case, Lightning works atop Bitcoin, interacting with it through smart contracts.</p>
<p><strong><em>What is a Lightning Channel?</em></strong> A Lightning Channel is a connection between two Lightning users. Each of the users locks up some number of bitcoins on the Bitcoin blockchain using a multi-sig signed by both of them. The two users can then exchange bitcoins through their Lightning channel without ever writing to the Bitcoin blockchain. Only when they want to close out their channel do they settle their bitcoins, based on the final division of coins.</p>
<p><strong><em>What is a Lightning Network?</em></strong> Putting together a number of Lightning Channels creates the Lightning Network. This allows two users who have not created a channel between themselves to exchange bitcoins using Lightning: the protocol forms a chain of Channels between the two users, then exchanges the coins through the chain using time-locked transactions.</p>
<p><strong><em>What are the Advantages of Lightning?</em></strong> Lightning allows for faster transactions with lower fees. This creates the real possibility of bitcoin-funded micropayments. It also offers better privacy, since it's off-chain with only the first and last states of the transaction being written to the immutable Bitcoin ledger.</p>
<p><strong><em>What are the Disadvantages of Lightning?</em></strong> Lightning is still a very new technology and hasn't been tested as thoroughly as Bitcoin. That's not just a question of the technological implementation, but also whether the design itself can be gamed in any unexpected ways.</p>
<h3 id="lightning---in-short"><a class="header" href="#lightning---in-short">Lightning - In Short</a></h3>
<p>One way to think of Lightning is: <em>a way to transact bitcoins using off-chain channels between pairs of people, so that only a first and final state have to be written to the blockchain</em>.</p>
<h2 id="summary-introducing-bitcoin"><a class="header" href="#summary-introducing-bitcoin">Summary: Introducing Bitcoin</a></h2>
<p>Bitcoin is a peer-to-peer system that allows for the transfer of funds through transactions that are locked with puzzles. These puzzles are dependent upon public-key elliptic-curve cryptography. When you generalize the ideas behind Bitcoin, you get blockchains, a technology that's currently growing and innovating. When you expand the ideas behind Bitcoin, you get layer-2 protocols such as Lightning, which expand the currency's potential.</p>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<p>Advance through &quot;Preparing for Bitcoin&quot; with <a href="02_0_Setting_Up_a_Bitcoin-Core_VPS.html">Chapter Two: Setting Up a Bitcoin-Core VPS</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-two-creating-a-bitcoin-core-vps"><a class="header" href="#chapter-two-creating-a-bitcoin-core-vps">Chapter Two: Creating a Bitcoin-Core VPS</a></h1>
<p>To get started with Bitcoin, you first need to set up a machine running Bitcoin. The articles in this chapter describe how to do so, primarily by using a VPS (Virtual Private Server).</p>
<h2 id="objectives-for-this-chapter"><a class="header" href="#objectives-for-this-chapter">Objectives for this Chapter</a></h2>
<p>After working through this chapter, a developer will be able to:</p>
<ul>
<li>Decide Between the Five Major Types of Bitcoin Nodes</li>
<li>Create a Bitcoin Node for Development</li>
<li>Create a Local Instance of the Bitcoin Blockchain</li>
</ul>
<p>Supporting objectives include the ability to:</p>
<ul>
<li>Understand the Basic Network Setup of the VPS</li>
<li>Decide Which Security Priorities to Implement</li>
<li>Understand the Difference between Pruned and Unpruned Nodes</li>
<li>Understand the Difference between Mainnet, Testnet, and Regtest Nodes</li>
<li>Interpret the Basics of the Bitcoin Configuration File</li>
</ul>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<p>You don't actually need to read this entire chapter. Decide if you want to run a StackScript to set a node up on a Linode VPS (§2.2); or you want to set up on a different environment, such as on an AWS machine or a Mac (§2.3). Then, jump to the appropriate section. Additional information on our suggested setups may also be found in <a href="A1_0_Understanding_Bitcoin_Standup.html">Appendix I</a>.</p>
<ul>
<li><a href="02_1_Setting_Up_a_Bitcoin-Core_VPS_with_StackScript.html">Section One: Setting Up a Bitcoin Core VPS with Bitcoin Standup</a></li>
<li><a href="02_2_Setting_Up_Bitcoin_Core_Other.html">Section Two: Setting Up a Bitcoin Core Machine via Other Means</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-setting-up-a-bitcoin-core-vps-with-bitcoin-standup"><a class="header" href="#21-setting-up-a-bitcoin-core-vps-with-bitcoin-standup">2.1: Setting Up a Bitcoin-Core VPS with Bitcoin Standup</a></h1>
<p>This document explains how to set up a VPS (Virtual Private Sever) to run a Bitcoin node on Linode.com, installed using an automated StackScript from the <a href="https://github.com/BlockchainCommons/Bitcoin-Standup-Scripts">Bitcoin Standup project</a>. You just need to enter a few commands and boot your VPS. Almost immediately after you boot, you'll find your new Bitcoin node happily downloading blocks.</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> Don’t use a VPS for a bitcoin wallet with significant real funds; see http://blog.thestateofme.com/2012/03/03/lessons-to-be-learned-from-the-linode-bitcoin-incident/ . It is very nice to be able experiment with real bitcoin transactions on a live node without tying up a self-hosted server on a local network. It's also useful to be able to use an iPhone or iPad to communicate via SSH to your VPS to do some simple bitcoin tasks. But a higher level of safety is required for significant funds.</p>
</blockquote>
<ul>
<li>If you want to understand what this setup does, read <a href="A1_0_Understanding_Bitcoin_Standup.html">Appendix I: Understanding Bitcoin Standup</a> as you install.</li>
<li>If you want to instead setup on a machine other than a Linode VPS, such as an AWS machine or a Mac, goto <a href="02_2_Setting_Up_Bitcoin_Core_Other.html">§2.2: Setting Up a Bitcoin-Core via Other Means</a></li>
<li>If you already have a Bitcoin node running, goto <a href="03_0_Understanding_Your_Bitcoin_Setup.html">Chapter Three: Understanding Your Bitcoin Setup</a>.</li>
</ul>
<h2 id="getting-started-with-linode"><a class="header" href="#getting-started-with-linode">Getting Started with Linode</a></h2>
<p>Linode is a Cloud Hosting service that offers quick, cheap Linux servers with SSD storage. We use them for this tutorial primarily because their BASH-driven StackScripts offer an easy way to automatically set up a Bitcoin node with no fuss and no muss.</p>
<h3 id="set-up-a-linode-account"><a class="header" href="#set-up-a-linode-account">Set Up a Linode Account</a></h3>
<p>You can create a Linode account by going here:</p>
<pre><code>https://www.linode.com
</code></pre>
<p>If you prefer, the following referral code will give you two months worth of free usage (up to $100), great for learning Bitcoin:</p>
<p><a href="https://www.linode.com/?r=3c7fa15a78407c9a3d4aefb027539db2557b3765">https://www.linode.com/?r=3c7fa15a78407c9a3d4aefb027539db2557b3765</a></p>
<p>You'll need to provide an email address and later preload money from a credit card or PayPal for future costs.</p>
<p>When you're done, you should land on <a href="https://cloud.linode.com/dashboard">https://cloud.linode.com/dashboard</a>.</p>
<h3 id="consider-two-factor-authentication"><a class="header" href="#consider-two-factor-authentication">Consider Two-Factor Authentication</a></h3>
<p>Your server security won't be complete if people can break into your Linode account, so consider setting up Two-Factor Authentication for it. You can find this setting on your <a href="https://manager.linode.com/profile/auth">My Profile: Password &amp; Authentication page</a>. If you don't do this now, make a TODO item to come back and do it later.</p>
<h2 id="creating-the-linode-image-using-a-stackscript"><a class="header" href="#creating-the-linode-image-using-a-stackscript">Creating the Linode Image using a StackScript</a></h2>
<h3 id="load-the-stackscript"><a class="header" href="#load-the-stackscript">Load the StackScript</a></h3>
<p>Download the <a href="https://github.com/BlockchainCommons/Bitcoin-Standup-Scripts/blob/master/Scripts/LinodeStandUp.sh">Linode Standup Script</a> from the <a href="https://github.com/BlockchainCommons/Bitcoin-Standup-Scripts">Bitcoin Standup Scripts repo</a>. This script basically automates all Bitcoin VPS setup instructions. If you want to be particulary prudent, read it over carefully. If you are satisfied, you can copy that StackScript into your own account by going to the <a href="https://cloud.linode.com/stackscripts?type=account">Stackscripts page</a> on your Linode account and selecting to <a href="https://cloud.linode.com/stackscripts/create">Create New Stackscript</a>. Give it a good name (we use <code>Bitcoin Standup</code>), then copy and paste the script. Choose Debian 11 for your target image and &quot;Save&quot; it.</p>
<h3 id="do-the-initial-setup"><a class="header" href="#do-the-initial-setup">Do the Initial Setup</a></h3>
<p>You're now ready to create a node based on the Stackscript.</p>
<ol>
<li>On the <a href="https://cloud.linode.com/stackscripts?type=account">Stackscripts page</a>, click on the &quot;...&quot; to the right of your new script and choose &quot;Deploy New Linode&quot;.</li>
<li>Fill in a short and a fully qualified hostname
<ul>
<li><strong>Short Hostname.</strong> Pick a name for your VPS. For example, &quot;mybtctest&quot;.</li>
<li><strong>Fully Qualified Hostname.</strong> If you're going to include this VPS as part of a network with full DNS records, type in the hostname with its domain. For example, &quot;mybtctest.mydomain.com&quot;. Otherwise, just repeat the short hostname and add &quot;.local&quot;, for example &quot;mybtctest.local&quot;.</li>
</ul>
</li>
<li>Enter the password for the &quot;standup&quot; user.</li>
<li>Fill in the appropriate advanced options. 
<ul>
<li><strong>X25519 Public Key.</strong> This is a public key to add to Tor's list of authorized clients. If you don't use it, anyone who gets the QR code for your node can access it. You'll get this public key from whichever client you're using to connect to your node. For example, if you use <a href="https://github.com/BlockchainCommons/FullyNoded-2">FullyNoded 2</a>, you can go to its settings and &quot;Export Tor V3 Authentication Public Key&quot; for use here.</li>
<li><strong>Installation Type.</strong> This is likely &quot;Mainnet&quot; or &quot;Pruned Mainnet&quot; if you are setting up a node for usage and &quot;Testnet&quot; or &quot;Pruned Testnet&quot; if you're just playing around. The bulk of this tutorial will assume you chose &quot;Pruned Testnet&quot;, but you should still be able to follow along with other types. See the <a href="02_1_Setting_Up_a_Bitcoin-Core_VPS_with_StackScript.html#synopsis-bitcoin-installation-types">Synopsis</a> for more information on these options. (Note that if you plan to try out the Lightning chapters, you'll probably want to use an Unpruned node, as working with Pruned nodes on Lightning is iffy. See <a href="18_1_Verifying_Your_Lightning_Setup.html#compiling-the-source-code">§18.1</a> for the specifics.)</li>
<li><strong>SSH Key.</strong> Copy your local computer's SSH key here; this allows you be able to automatically login in via SSH to the standup account. If you haven't setup an SSH key on your local computer yet, there are good instructions for it on <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/">Github</a>.  You may also want to add your SSH key into your Linode LISH (Linode Interactive Shell) by going to your &quot;Linode Home Page / My Preferences / LISH Settings /  LISH Keys&quot;. Using an SSH key will give you a simpler and safer way to log in to your server.</li>
<li><strong>SSH-Allowed IPs.</strong> This is a comma-separated list of IPs that will be allowed to SSH into the VPS. For example &quot;192.168.1.15,192.168.1.16&quot;. If you do not enter any IPs, <em>your VPS will not be very secure</em>. It will constantly be bombarded by attackers trying to find their way in, and they may very well succeed.</li>
</ul>
</li>
<li>Select an Image
<ul>
<li><strong>Target Image.</strong> If you followed the instructions, this will only allow you to select &quot;Debian 11&quot; (though previous versions of this Stackscript worked with Debian 9 or 10and might still).</li>
</ul>
</li>
<li>Choose a region for where the Linode will be located.</li>
</ol>
<p><em>The remaining questions all have to do with the mechanics of the VPS deployment and should be left as they are with one exception: bump the Swap Disk from 256MB to 512MB, to ensure that you have enough memory to download the blockchain.</em></p>
<h3 id="choose-other-standup-options"><a class="header" href="#choose-other-standup-options">Choose Other Standup Options</a></h3>
<p>Blockchain Commons is currently in the process of expanding its Bitcoin Standup Scripts with options to install Lightning and other Bitcoin apps of note. Take a look at any extra options, and see if they're things that you'd like to play with. In particular, if Lightning is an option, we suggest installing it, because it will make <a href="18_0_Understanding_Your_Lightning_Setup.html">Chapter 18</a> and <a href="19_0_Using_Lightning.html">Chapter 19</a> much easier. </p>
<h3 id="choose-a-linode-plan"><a class="header" href="#choose-a-linode-plan">Choose a Linode Plan</a></h3>
<p>You'll next to choose a Linode plan.</p>
<p>Linode will default to Dedicated-CPU plans, but you can select the more cost-efficient Shared-CPU instead. A Shared-CPU Linode 4GB will suffice for most setups, including: Pruned Mainnet, Pruned Testnet, and even non-Pruned Testnet. They all use less than 50G of storage and 4GB is a comfortable amount of memory. This is the setup we suggest. It runs $20 per month.</p>
<p>If you want to instead have a non-Pruned Mainnet in a VPS, you'll need to install a Linode with a disk in excess of 280G(!), which is currently the Linode 16GB, which has 320G of storage and 16G of memory and costs approximately $80 per month. We do <em>not</em> suggest this.</p>
<p>The following chart shows minimum requirements</p>
<table><thead><tr><th>Setup</th><th>Memory</th><th>Storage</th><th>Linnode</th></tr></thead><tbody>
<tr><td>Mainnet</td><td>2G</td><td>280G</td><td>Linode 16GB</td></tr>
<tr><td>Pruned Mainnet</td><td>2G</td><td>~5G</td><td>Linode 4GB</td></tr>
<tr><td>Testnet</td><td>2G</td><td>~15G</td><td>Linode 4GB</td></tr>
<tr><td>Pruned Testnet</td><td>2G</td><td>~5G</td><td>Linode 4GB</td></tr>
<tr><td>Regtest</td><td>2G</td><td>~</td><td>Linode 4GB</td></tr>
</tbody></table>
<p>Note, there may be ways to reduce both costs.</p>
<ul>
<li>For the machines we suggest as <strong>Linode 4GB</strong>, you may be able to reduce that to a Linode 2GB. Some versions of Bitcoin Core have worked well at that size, some have occasionally run out of memory and then recovered, and some have continuously run out of memory. Remember to up that swap space to maximize the odds of this working. Use at your own risk.</li>
<li>For the Unpruned Mainnet, which we suggest as a <strong>Linode 16GB</strong>, you can probably get by with a Linode 4GB, but add <a href="https://cloud.linode.com/volumes">Block Storage</a> sufficient to store the blockchain. This is certainly a better long-term solution since the Bitcoin blockchain's storage requirements continuously increase if you don't prune, while the CPU requirements don't (or don't to the same degree). A 320 GibiByte storage would be $32 a month, which combined with a Linode 4GB is $52 a month, instead of $80, and more importantly you can keep growing it. We don't fully document this setup for two reasons (1) we don't suggest the unpruned mainnet setup, and so we suspect it's a much less common setup; and (2) we haven't tested how Linodes volumes compare to their intrinic SSDs for performance and usage. But there's full documentation on the Block Storage page. You'd need to set up the Linode, run its stackscript, but then interrupt it to move the blockchain storage overly to a newly commissioned volume before continuing.</li>
</ul>
<p>If you are running a deployment that will be transacting real Bitcoins, you may want to alternatively consider a Dedicated-CPU Linode, which tends to run 50% more expensive than the Shared-CPU Linode. We've generally found the Shared CPUs to be entirely sufficient, but for a wide deployment, you may wish to consider higher levels of reliability.</p>
<h3 id="do-the-final-setup"><a class="header" href="#do-the-final-setup">Do the Final Setup</a></h3>
<p>The last thing you need to do is enter a root password. (If you missed anything, you'll be told so now!)</p>
<p>Click &quot;Deploy&quot; to initialize your disks and to prepare your VPS. The whole queue should run in less than a minute. When it's done you should see in the &quot;Host Job Queue&quot;, green &quot;Success&quot; buttons stating &quot;Disk Create from StackScript - Setting password for root… done.&quot; and &quot;Create Filesystem - 256MB Swap Image&quot;.</p>
<p>You may now want to change your Linode VPS's name from the default <code>linodexxxxxxxx</code>.  Go to the Settings tab, and change the label to be more useful, such as your VPS's short hostname. For instance you might name it <code>bitcoin-testnet-pruned</code> to differentiate it from other VPSs in your account.</p>
<h2 id="login-to-your-vps"><a class="header" href="#login-to-your-vps">Login to Your VPS</a></h2>
<p>If you watch your Linode control panel, you should see the new computer spin up. When the job has reached 100%, you'll be able to login.</p>
<p>First, you'll need the IP address. Click on the &quot;Linodes&quot; tab and you should see a listing of your VPS, the fact that it's running, its &quot;plan&quot;, its IP address, and some other information.</p>
<p>Go to your local console and login to the <code>standup</code> account using that address:</p>
<pre><code>ssh standup@[IP-ADDRESS]
</code></pre>
<p>For example:</p>
<pre><code>ssh standup@192.168.33.11
</code></pre>
<p>If you configured your VPS to use an SSH key, the login should be automatic (possibly requiring your SSH password to unlock your key). If you didn't configure a SSH key, then you'll need to type in the user1 password.</p>
<h3 id="wait-a-few-minutes"><a class="header" href="#wait-a-few-minutes">Wait a Few Minutes</a></h3>
<p>Here's a little catch: <em>your StackScript is running right now</em>. The BASH script gets executed the first time the VPS is booted. That means your VPS isn't ready yet.</p>
<p>The total run time is about 10 minutes. So, go take a break, get an espresso, or otherwise relax for a few minutes. There are two parts of the script that take a while: the updating of all the Debian packages; and the downloading of the Bitcoin code. They shouldn't take more than 5 minutes each, which means if you come back in 10 minutes, you'll probably be ready to go.</p>
<p>If you're impatient you can jump ahead and <code>sudo tail -f /standup.log</code> which will display the current progress of installation, as described in the next section.</p>
<h2 id="verify-your-installation"><a class="header" href="#verify-your-installation">Verify Your Installation</a></h2>
<p>You'll know that stackscrpit is done when the <code>tail</code> of the <code>standup.log</code> says something like the following:</p>
<pre><code>/root/StackScript - Bitcoin is setup as a service and will automatically start if your VPS reboots and so is Tor
/root/StackScript - You can manually stop Bitcoin with: sudo systemctl stop bitcoind.service
/root/StackScript - You can manually start Bitcoin with: sudo systemctl start bitcoind.service
</code></pre>
<p>At that point, your home directory should look like this:</p>
<pre><code>$ ls
bitcoin-22.0-x86_64-linux-gnu.tar.gz  keys.txt  SHA256SUMS  SHA256SUMS.asc
</code></pre>
<p>These are the various files that were used to install Bitcoin on your VPS. <em>None</em> of them are necessary. We've just left them in case you want to do any additional verification. Otherwise, you can delete them:</p>
<pre><code>$ rm *
</code></pre>
<h3 id="verify-the-bitcoin-setup"><a class="header" href="#verify-the-bitcoin-setup">Verify the Bitcoin Setup</a></h3>
<p>In order to ensure that the downloaded Bitcoin release is valid, the StackScript checks both the signature and the SHA checksum. You should verify that both of those tests came back right:</p>
<pre><code>$ sudo grep VERIFICATION /standup.log
</code></pre>
<p>If you see something like the following, all should be well:</p>
<pre><code>./standup.sh - SIG VERIFICATION SUCCESS: 9 GOOD SIGNATURES FOUND.
./standup.sh - SHA VERIFICATION SUCCESS / SHA: bitcoin-22.0-x86_64-linux-gnu.tar.gz: OK
</code></pre>
<p>If either of those two checks instead reads &quot;VERIFICATION ERROR&quot;, then there's a problem.</p>
<p>The log also contains more information on the Signatures, if you want to make sure you know <em>who</em> signed the Bitcoin release:</p>
<pre><code>$ sudo grep -i good /standup.log
./standup.sh - SIG VERIFICATION SUCCESS: 9 GOOD SIGNATURES FOUND.
gpg: Good signature from &quot;Andrew Chow (Official New Key) &lt;achow101@gmail.com&gt;&quot; [unknown]
gpg: Good signature from &quot;Ben Carman &lt;benthecarman@live.com&gt;&quot; [unknown]
gpg: Good signature from &quot;Antoine Poinsot &lt;darosior@protonmail.com&gt;&quot; [unknown]
gpg: Good signature from &quot;Stephan Oeste (it) &lt;it@oeste.de&gt;&quot; [unknown]
gpg: Good signature from &quot;Michael Ford (bitcoin-otc) &lt;fanquake@gmail.com&gt;&quot; [unknown]
gpg: Good signature from &quot;Oliver Gugger &lt;gugger@gmail.com&gt;&quot; [unknown]
gpg: Good signature from &quot;Hennadii Stepanov (hebasto) &lt;hebasto@gmail.com&gt;&quot; [unknown]
gpg: Good signature from &quot;Jon Atack &lt;jon@atack.com&gt;&quot; [unknown]
gpg: Good signature from &quot;Wladimir J. van der Laan &lt;laanwj@visucore.com&gt;&quot; [unknown]
</code></pre>
<p>Since this is all scripted, it's possible that there's just been a minor change that has caused the script's checks not to work right. (This has happened a few times over the existence of the script that became Standup.) But, it's also possible that someone is trying to encourage you to run a fake copy of the Bitcoin daemon. So, <em>be very sure you know what happened before you make use of Bitcoin!</em></p>
<h3 id="read-the-logs"><a class="header" href="#read-the-logs">Read the Logs</a></h3>
<p>You may also want to read through all of the setup log files, to make sure that nothing unexpected happened during the installation.</p>
<p>It's best to look through the standard StackScript log file, which has all of the output, including errors:</p>
<p><code>$ sudo more /standup.log</code></p>
<p>Note that it is totally normal to see <em>some</em> errors, particularly when running the very noisy gpg software and when various things try to access the non-existant <code>/dev/tty</code> device.</p>
<p>If you want instead to look at a smaller set of info, all of the errors should be in:</p>
<p><code>$ sudo more /standup.err</code></p>
<p>It still has a fair amount of information that isn't errors, but it's a quicker read.</p>
<p>If all look good, congratulations, you have a functioning Bitcoin node using Linode!</p>
<h2 id="what-we-have-wrought"><a class="header" href="#what-we-have-wrought">What We Have Wrought</a></h2>
<p>Although the default Debian 11 image that we are using for your VPS has been modified by Linode to be relatively secure, your Bitcoin node as installed through the Linode StackScript is set up with an even higher level of security. You may find this limiting, or be unable to do things that you expect. Here are a few notes on that:</p>
<h3 id="protected-services"><a class="header" href="#protected-services">Protected Services</a></h3>
<p>Your Bitcoin VPS installation is minimal and allows almost no communication. This is done through the uncomplicated firewall (<code>ufw</code>), which blocks everything except SSH connections. There's also some additional security possible for your RFC ports, thanks to the hidden services installed by Tor.</p>
<p><strong>Adjusting UFW.</strong> You should probably leave UFW in its super-protected stage! You don't want to use a Bitcoin machine for other services, because everyone increases your vulnerability! If you decide otherwise, there are several <a href="https://www.digitalocean.com/community/tutorials/ufw-essentials-common-firewall-rules-and-commands">guides to UFW</a> that will allow you to add services. As advertised, it's uncomplicated. For example adding mail services would just require opening the mail port: <code>sudo ufw allow 25</code>. But don't do that.</p>
<p><strong>Adjusting Tor.</strong> You might want to better protect services like SSH. See <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/14_0_Using_Tor.md">Chapter 14: Using Tor</a> for more on Tor.</p>
<h3 id="protected-shells"><a class="header" href="#protected-shells">Protected Shells</a></h3>
<p>If you defined &quot;SSH-allowed IPs&quot;, SSH (and SCP) access to the server is severely restricted. <code>/etc/hosts.deny</code> disallows anyone from logging in. <em>We do not suggest changing this</em>. <code>/etc/hosts.allow</code> then allows specific IP addresses. Just add more IP addresses in a comma-separated list if you need to offer more access.</p>
<p>For example:</p>
<pre><code>sshd: 127.0.0.1, 192.128.23.1
</code></pre>
<h3 id="automated-upgrades"><a class="header" href="#automated-upgrades">Automated Upgrades</a></h3>
<p>Debian is also set up to automatically upgrade itself, to ensure that it remains abreast of the newest security patches.</p>
<p>If for some reason you wanted to change this (<em>we don't suggest it</em>), you can do this:</p>
<pre><code>echo &quot;unattended-upgrades unattended-upgrades/enable_auto_updates boolean false&quot; | debconf-set-selections
</code></pre>
<p><em>If you'd like to know more about what the Bitcoin Standup stackscript does, please see <a href="A1_0_Understanding_Bitcoin_Standup.html">Appendix I: Understanding Bitcoin Standup</a>.</em></p>
<h2 id="playing-with-bitcoin"><a class="header" href="#playing-with-bitcoin">Playing with Bitcoin</a></h2>
<p>So now you probably want to play with Bitcoin!</p>
<p>But wait, your Bitcoin daemon is probably still downloading blocks. The <code>bitcoin-cli getblockcount</code> will tell you how you're currently doing:</p>
<pre><code>$ bitcoin-cli getblockcount
1771352
</code></pre>
<p>If it's different every time you type the command, you need to wait before working with Bitcoin. This takes 1-6 hours currently for a  pruned setup, depending on your precise machine. </p>
<p>But, once it settles at a number, you're ready to continue!</p>
<p>Still, it might be time for a few more espressos. But soon enough, your system will be ready to go, and you'll be read to start experimenting.</p>
<h2 id="summary-setting-up-a-bitcoin-core-vps-by-hand"><a class="header" href="#summary-setting-up-a-bitcoin-core-vps-by-hand">Summary: Setting Up a Bitcoin-Core VPS by Hand</a></h2>
<p>Creating a Bitcoin-Core VPS with the Standup scripts made the whole process quick, simple and (hopefully) painless.</p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next?</a></h2>
<p>You have a few options for what's next:</p>
<ul>
<li>Read the <a href="https://github.com/BlockchainCommons/Bitcoin-Standup-Scripts/blob/master/Scripts/LinodeStandUp.sh">StackScript</a> to understand your setup.</li>
<li>Read what the StackScript does in <a href="A1_0_Understanding_Bitcoin_Standup.html">Appendix I</a>.</li>
<li>Choose an entirely alternate methodology in <a href="02_2_Setting_Up_Bitcoin_Core_Other.html">§2.2: Setting Up a Bitcoin-Core Machine via Other Means</a>.</li>
<li>Move on to &quot;bitcoin-cli&quot; with <a href="03_0_Understanding_Your_Bitcoin_Setup.html">Chapter Three: Understanding Your Bitcoin Setup</a>.</li>
</ul>
<h2 id="synopsis-bitcoin-installation-types"><a class="header" href="#synopsis-bitcoin-installation-types">Synopsis: Bitcoin Installation Types</a></h2>
<p><strong>Mainnet.</strong> This will download the entirety of the Bitnet blockchain. That's 280G of data (and getting more every day). </p>
<p><strong>Pruned Mainnet.</strong> This will cut the blockchain you're storing down to just the last 550 blocks. If you're not mining or running some other Bitcoin service, this should be plenty for validation.</p>
<p><strong>Testnet.</strong> This gives you access to an alternative Bitcoin blockchain where the Bitcoins don't actually have value. It's intended for experimentation and testing.</p>
<p><strong>Pruned Testnet.</strong> This is just the last 550 blocks of Testnet ... because the Testnet blockchain is pretty big now too.</p>
<p><strong>Private Regtest.</strong> This is Regression Testing Mode, which lets you run a totally local Bitcoin server. It allows for even more in-depth testing. There's no pruning needed here, because you'll be starting from scratch. This is a very different setup, and so is covered in <a href="A3_0_Using_Bitcoin_Regtest.html">Appendix 3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-setting-up-a-bitcoin-core-machine-via-other-means"><a class="header" href="#22-setting-up-a-bitcoin-core-machine-via-other-means">2.2: Setting Up a Bitcoin-Core Machine via Other Means</a></h1>
<p>The previous section, <a href="02_1_Setting_Up_a_Bitcoin-Core_VPS_with_StackScript.html">§2.1: Setting Up a Bitcoin-Core VPS with Bitcoin Standup</a>, presumed that you would be creating a full node on a VPS using a Linode Stackscript. However, you can actually create a Bitcoin-Core instance via any methodology of your choice and still follow along with the later steps of this tutorial.</p>
<p>Following are other setup methodologies that we are aware of:</p>
<ul>
<li><em><a href="A2_0_Compiling_Bitcoin_from_Source.html">Compiling from Source</a>.</em> If you prefer to compile Bitcoin Core by hand, that's covered in Appendix 2.</li>
<li><em><a href="https://github.com/BlockchainCommons/GordianNode-macOS">Using GordianNode-macOS</a>.</em> If you have a modern Mac, you can use Blockchain Commons' <em>GordianNode</em> app, powered by <em>BitcoinStandup</em>, to install a full node on your Mac.</li>
<li><em><a href="https://github.com/BlockchainCommons/Bitcoin-Standup-Scripts">Using Other Bitcoin Standup Scripts</a>.</em> Blockchain Commons also offers a version of the Linode script that you used that can be run from the command line on any Debian or Ubuntu machine. This tends to be the leading-edge script, which means that it's more likely to feature new functions, like Lightning installation.</li>
<li><em><a href="https://wolfmcnally.com/115/developer-notes-setting-up-a-bitcoin-node-on-aws/">Setting Up a Bitcoin Node on AWS</a>.</em> @wolfmcnally has written a step-by-step tutorial for setting up Bitcoin-Core with Amazon Web Services (AWS).</li>
<li><em><a href="https://medium.com/@meeDamian/bitcoin-full-node-on-rbp3-revised-88bb7c8ef1d1">Setting Up a Bitcoin Node on a Raspberry Pi 3</a>.</em> Damian Mee explains how to set up a headless full node on a Raspberry Pi 3.</li>
</ul>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next?</a></h2>
<p>Unless you want to return to one of the other methodologies for creating a Bitcoin-Core node, you should:</p>
<ul>
<li>Move on to &quot;bitcoin-cli&quot; with <a href="03_0_Understanding_Your_Bitcoin_Setup.html">Chapter Three: Understanding Your Bitcoin Setup</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-three-understanding-your-bitcoin-setup"><a class="header" href="#chapter-three-understanding-your-bitcoin-setup">Chapter Three: Understanding Your Bitcoin Setup</a></h1>
<p>You're now ready to begin working with the <code>bitcoin-cli</code> command-line interface. But that first requires that you understand your Bitcoin setup and its wallet features, which is what will be explained in this chapter.</p>
<p>For this and future chapters, we presume that you have a VPS with Bitcoin installed, running <code>bitcoind</code>. We also presume that you are connected to testnet, allowing for access to bitcoins without using real funds. You can either do this with Bitcoin Standup at Linode.com, per <a href="02_1_Setting_Up_a_Bitcoin-Core_VPS_with_StackScript.html">§2.1: Setting up a Bitcoin-Core VPS with Bitcoin Standup</a>, or via other means, per <a href="02_2_Setting_Up_Bitcoin_Core_Other.html">§2.2: Setting up a Bitcoin-Core Machine via Other Means</a>.</p>
<h2 id="objectives-for-this-chapter-1"><a class="header" href="#objectives-for-this-chapter-1">Objectives for This Chapter</a></h2>
<p>After working through this chapter, a developer will be able to:</p>
<ul>
<li>Demonstrate that Their Bitcoin Node is Installed and Up-to-date</li>
<li>Create an Address to Receive Bitcoin Funds</li>
<li>Use Basic Wallet Commands</li>
<li>Create an Address from a Descriptor</li>
</ul>
<p>Supporting objectives include the ability to:</p>
<ul>
<li>Understand the Basic Bitcoin File Layout</li>
<li>Use Basic Informational Commands</li>
<li>Understand What a Bitcoin Address Is</li>
<li>Understand What a Wallet Is</li>
<li>Understand How to Import Addresses</li>
</ul>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="03_1_Verifying_Your_Bitcoin_Setup.html">Section One: Verifying Your Bitcoin Setup</a></li>
<li><a href="03_2_Knowing_Your_Bitcoin_Setup.html">Section Two: Knowing Your Bitcoin Setup</a></li>
<li><a href="03_3_Setting_Up_Your_Wallet.html">Section Three: Setting Up Your Wallet</a>
<ul>
<li><a href="03_3__Interlude_Using_Command-Line_Variables.html">Interlude: Using Command-Line Variables</a></li>
</ul>
</li>
<li><a href="03_4_Receiving_a_Transaction.html">Section Four: Receiving a Transaction</a></li>
<li><a href="03_5_Understanding_the_Descriptor.html">Section Five: Understanding the Descriptor</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-verifying-your-bitcoin-setup"><a class="header" href="#31-verifying-your-bitcoin-setup">3.1: Verifying Your Bitcoin Setup</a></h1>
<p>Before you start playing with Bitcoin, you should ensure that everything is setup correctly.</p>
<h2 id="create-your-aliases"><a class="header" href="#create-your-aliases">Create Your Aliases</a></h2>
<p>We suggest creating some aliases to make it easier to use Bitcoin.</p>
<p>You can do so by putting them in your <code>.bash_profile</code>, <code>.bashrc</code> or <code>.profile</code>.</p>
<pre><code>cat &gt;&gt; ~/.bash_profile &lt;&lt;EOF
alias btcdir=&quot;cd ~/.bitcoin/&quot; #linux default bitcoind path
alias bc=&quot;bitcoin-cli&quot;
alias bd=&quot;bitcoind&quot;
alias btcinfo='bitcoin-cli getwalletinfo | egrep &quot;\&quot;balance\&quot;&quot;; bitcoin-cli getnetworkinfo | egrep &quot;\&quot;version\&quot;|connections&quot;; bitcoin-cli getmininginfo | egrep &quot;\&quot;blocks\&quot;|errors&quot;'
EOF
</code></pre>
<p>After you enter these aliases you can either <code>source .bash_profile</code> to input them or just log out and back in.</p>
<p>Note that these aliases includes shortcuts for running <code>bitcoin-cli</code>, for running <code>bitcoind</code>, and for going to the Bitcoin directory. These aliases are mainly meant to make your life easier. We suggest you create other aliases to ease your use of frequent commands (and arguments) and to minimize errors. Aliases of this sort can be even more useful if you have a complex setup where you regularly run commands associated with Mainnet, with Testnet, <em>and</em> with Regtest, as explained further below.</p>
<p>With that said, use of these aliases in <em>this</em> document might accidentally obscure the core lessons being taught about Bitcoin, so the only alias directly used here is <code>btcinfo</code> because it encapsulates  much longer and more complex command. Otherwise, we show the full commands; adjust for your own use as appropriate.</p>
<h2 id="run-bitcoind"><a class="header" href="#run-bitcoind">Run Bitcoind</a></h2>
<p>You'll begin your exploration of the Bitcoin network with the <code>bitcoin-cli</code> command. However, bitcoind <em>must</em> be running to use bitcoin-cli, as bitcoin-cli sends JSON-RPC commands to the bitcoind. If you used our standard setup, bitcoind should already be up and running. You can double check by looking at the process table.</p>
<pre><code>$ ps auxww | grep bitcoind
standup    455  1.3 34.4 3387536 1392904 ?     SLsl Jun16  59:30 /usr/local/bin/bitcoind -conf=/home/standup/.bitcoin/bitcoin.conf
</code></pre>
<p>If it's not running, you'll want to run <code>/usr/local/bin/bitcoind -daemon</code> by hand and also place it in your crontab.</p>
<h2 id="verify-your-blocks"><a class="header" href="#verify-your-blocks">Verify Your Blocks</a></h2>
<p>You should have the whole blockchain downloaded before you start playing. Just run the <code>bitcoin-cli getblockcount</code> alias to see if it's all loaded. </p>
<pre><code>$ bitcoin-cli getblockcount
1772384
</code></pre>
<p>That tells you what's loaded; you'll then need to check that against an online service that tells you the current block height.</p>
<blockquote>
<p>:book: <em><strong>What is Block Height?</strong></em> Block height is the the distance that a particular block is removed from the genesis block. The current block height is the block height of the newest block added to a blockchain.</p>
</blockquote>
<p>You can do this by looking at a blocknet explorer, such as <a href="https://live.blockcypher.com/btc-testnet/">the Blockcypher Testnet explorer</a>. Does its most recent number match your <code>getblockcount</code>? If so, you're up to date.</p>
<p>If you'd like an alias to look at everything at once, the following currently works for Testnet, but may disappear at some time in the future:</p>
<pre><code>$ cat &gt;&gt; ~/.bash_profile &lt;&lt; EOF
alias btcblock=&quot;echo \\\`bitcoin-cli getblockcount 2&gt;&amp;1\\\`/\\\`wget -O - https://blockstream.info/testnet/api/blocks/tip/height 2&gt; /dev/null | cut -d : -f2 | rev | cut -c 1- | rev\\\`&quot;
EOF
$ source .bash_profile 
$ btcblock
1804372/1804372
</code></pre>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> Remember that this tutorial generally assumes that you are using testnet. If you're using the mainnet instead, you can retrieve the current block height with: <code>wget -O - http://blockchain.info/q/getblockcount 2&gt;/dev/null</code>. You can replace the latter half of the <code>btblock</code> alias (after <code>/</code>) with that.</p>
</blockquote>
<p>If you're not up-to-date, but your <code>getblockcount</code> is increasing, no problem. Total download time can take from an hour to several hours, depending on your setup.</p>
<h2 id="optional-know-your-server-types"><a class="header" href="#optional-know-your-server-types">Optional: Know Your Server Types</a></h2>
<blockquote>
<p><strong>TESTNET vs MAINNET:</strong> When you set up your node, you choose to create it as either a Mainnet, Testnet, or Regtest node. Though this document presumes a testnet setup, it's worth understanding how you might access and use the other setup types — even all on the same machine! But, if you're a first-time user, skip on past this, as it's not necessary for a basic setup.</p>
</blockquote>
<p>The type of setup is mainly controlled through the ~/.bitcoin/bitcoin.conf file. If you're running testnet, it probably contains this line:</p>
<pre><code>testnet=1
</code></pre>
<p>If you're running regtest, it probably contains this line:</p>
<pre><code>regtest=1
</code></pre>
<p>However, if you want to run several different sorts of nodes simultaneously, you should leave the testnet (or regtest) flag out of your configuration file. You can then choose whether you're using the mainnet, the testnet, or your regtest every time you run bitcoind or bitcoin-cli.</p>
<p>Here's a set of aliases that would make that easier by creating a specific alias for starting and stopping the bitcoind, for going to the bitcoin directory, and for running bitcoin-cli, for each of the mainnet (which has no extra flags), the testnet (which is -testnet), or your regtest (which is -regtest).</p>
<pre><code>cat &gt;&gt; ~/.bash_profile &lt;&lt;EOF
alias bcstart=&quot;bitcoind -daemon&quot;
alias btstart=&quot;bitcoind -testnet -daemon&quot;
alias brstart=&quot;bitcoind -regtest -daemon&quot;

alias bcstop=&quot;bitcoin-cli stop&quot;
alias btstop=&quot;bitcoin-cli -testnet stop&quot;
alias brstop=&quot;bitcoin-cli -regtest stop&quot;

alias bcdir=&quot;cd ~/.bitcoin/&quot; #linux default bitcoin path
alias btdir=&quot;cd ~/.bitcoin/testnet&quot; #linux default bitcoin testnet path
alias brdir=&quot;cd ~/.bitcoin/regtest&quot; #linux default bitcoin regtest path

alias bc=&quot;bitcoin-cli&quot;
alias bt=&quot;bitcoin-cli -testnet&quot;
alias br=&quot;bitcoin-cli -regtest&quot;
EOF
</code></pre>
<p>For even more complexity, you could have each of your 'start' aliases use the -conf flag to load configuration from a different file. This goes far beyond the scope of this tutorial, but we offer it as a starting point for when your explorations of Bitcoin reaches the next level.</p>
<h2 id="summary-verifying-your-bitcoin-setup"><a class="header" href="#summary-verifying-your-bitcoin-setup">Summary: Verifying Your Bitcoin Setup</a></h2>
<p>Before you start playing with bitcoin, you should make sure that your aliases are set up, your bitcoind is running, and your blocks are downloaded. You may also want to set up some access to alternative Bitcoin setups, if you're an advanced user.</p>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next?</a></h2>
<p>Continue &quot;Understanding Your Bitcoin Setup&quot; with <a href="03_2_Knowing_Your_Bitcoin_Setup.html">§3.2: Knowing Your Bitcoin Setup</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-knowing-your-bitcoin-setup"><a class="header" href="#32-knowing-your-bitcoin-setup">3.2: Knowing Your Bitcoin Setup</a></h1>
<p>Before you start playing with Bitcoin, you may always want to come to a better understanding of your setup.</p>
<h2 id="know-your-bitcoin-directory"><a class="header" href="#know-your-bitcoin-directory">Know Your Bitcoin Directory</a></h2>
<p>To start with, you should understand where everything is kept: the <code>~/.bitcoin</code> directory.</p>
<p>The main directory just contains your config file and the testnet directory:</p>
<pre><code>$ ls ~/.bitcoin
bitcoin.conf  testnet3
</code></pre>
<p>The setup guides in <a href="02_0_Setting_Up_a_Bitcoin-Core_VPS.html">Chapter Two: Creating a Bitcoin-Core VPS</a> laid out a standardized config file. <a href="03_1_Verifying_Your_Bitcoin_Setup.html">§3.1: Verifying Your Bitcoin Setup</a> suggested how to change it to support more advanced setups. If you're interested in learning even more about the config file, you may wish to consult <a href="https://jlopp.github.io/bitcoin-core-config-generator/">Jameson Lopp's Bitcoin Core Config Generator</a>.</p>
<p>Moving back to your ~/.bitcoin directory, you'll find that the testnet3 directory contains all of the guts:</p>
<pre><code>$ ls ~/.bitcoin/testnet3
banlist.dat   blocks	  debug.log	     mempool.dat	peers.dat
bitcoind.pid  chainstate  fee_estimates.dat  onion_private_key	wallets
</code></pre>
<p>You shouldn't mess with most of these files and directories — particularly not the <code>blocks</code> and <code>chainstate</code> directories, which contain all of the blockchain data, and the information in your <code>wallets</code> directory, which contains your personal wallet. However, do take careful note of the <code>debug.log</code> file, which you should refer to if you ever have problems with your setup.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> If you're using mainnet, then <em>everything</em> will instead be placed in the main <code>~/.bitcoin</code> directory. These various setups <em>do</em> elegantly stack, so if you are using mainnet, testnet, and regtest, you'll find that <code>~/.bitcoin</code> contains your config file and your mainnet data, the <code>~/.bitcoin/testnet3</code> directory contains your testnet data, and the <code>~/.bitcoin/regtest</code> directory contains your regtest data.</p>
</blockquote>
<h2 id="know-your-bitcoin-cli-commands"><a class="header" href="#know-your-bitcoin-cli-commands">Know Your Bitcoin-cli Commands</a></h2>
<p>Most of your early work will be done with the <code>bitcoin-cli</code> command, which offers an easy interface to <code>bitcoind</code>. If you ever want more information on its usage, just run it with the <code>help</code> argument. Without any other arguments, it shows you every possible command:</p>
<pre><code>$ bitcoin-cli help
== Blockchain ==
getbestblockhash
getblock &quot;blockhash&quot; ( verbosity )
getblockchaininfo
getblockcount
getblockfilter &quot;blockhash&quot; ( &quot;filtertype&quot; )
getblockhash height
getblockheader &quot;blockhash&quot; ( verbose )
getblockstats hash_or_height ( stats )
getchaintips
getchaintxstats ( nblocks &quot;blockhash&quot; )
getdifficulty
getmempoolancestors &quot;txid&quot; ( verbose )
getmempooldescendants &quot;txid&quot; ( verbose )
getmempoolentry &quot;txid&quot;
getmempoolinfo
getrawmempool ( verbose )
gettxout &quot;txid&quot; n ( include_mempool )
gettxoutproof [&quot;txid&quot;,...] ( &quot;blockhash&quot; )
gettxoutsetinfo
preciousblock &quot;blockhash&quot;
pruneblockchain height
savemempool
scantxoutset &quot;action&quot; ( [scanobjects,...] )
verifychain ( checklevel nblocks )
verifytxoutproof &quot;proof&quot;

== Control ==
getmemoryinfo ( &quot;mode&quot; )
getrpcinfo
help ( &quot;command&quot; )
logging ( [&quot;include_category&quot;,...] [&quot;exclude_category&quot;,...] )
stop
uptime

== Generating ==
generatetoaddress nblocks &quot;address&quot; ( maxtries )
generatetodescriptor num_blocks &quot;descriptor&quot; ( maxtries )

== Mining ==
getblocktemplate ( &quot;template_request&quot; )
getmininginfo
getnetworkhashps ( nblocks height )
prioritisetransaction &quot;txid&quot; ( dummy ) fee_delta
submitblock &quot;hexdata&quot; ( &quot;dummy&quot; )
submitheader &quot;hexdata&quot;

== Network ==
addnode &quot;node&quot; &quot;command&quot;
clearbanned
disconnectnode ( &quot;address&quot; nodeid )
getaddednodeinfo ( &quot;node&quot; )
getconnectioncount
getnettotals
getnetworkinfo
getnodeaddresses ( count )
getpeerinfo
listbanned
ping
setban &quot;subnet&quot; &quot;command&quot; ( bantime absolute )
setnetworkactive state

== Rawtransactions ==
analyzepsbt &quot;psbt&quot;
combinepsbt [&quot;psbt&quot;,...]
combinerawtransaction [&quot;hexstring&quot;,...]
converttopsbt &quot;hexstring&quot; ( permitsigdata iswitness )
createpsbt [{&quot;txid&quot;:&quot;hex&quot;,&quot;vout&quot;:n,&quot;sequence&quot;:n},...] [{&quot;address&quot;:amount},{&quot;data&quot;:&quot;hex&quot;},...] ( locktime replaceable )
createrawtransaction [{&quot;txid&quot;:&quot;hex&quot;,&quot;vout&quot;:n,&quot;sequence&quot;:n},...] [{&quot;address&quot;:amount},{&quot;data&quot;:&quot;hex&quot;},...] ( locktime replaceable )
decodepsbt &quot;psbt&quot;
decoderawtransaction &quot;hexstring&quot; ( iswitness )
decodescript &quot;hexstring&quot;
finalizepsbt &quot;psbt&quot; ( extract )
fundrawtransaction &quot;hexstring&quot; ( options iswitness )
getrawtransaction &quot;txid&quot; ( verbose &quot;blockhash&quot; )
joinpsbts [&quot;psbt&quot;,...]
sendrawtransaction &quot;hexstring&quot; ( maxfeerate )
signrawtransactionwithkey &quot;hexstring&quot; [&quot;privatekey&quot;,...] ( [{&quot;txid&quot;:&quot;hex&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;,&quot;witnessScript&quot;:&quot;hex&quot;,&quot;amount&quot;:amount},...] &quot;sighashtype&quot; )
testmempoolaccept [&quot;rawtx&quot;,...] ( maxfeerate )
utxoupdatepsbt &quot;psbt&quot; ( [&quot;&quot;,{&quot;desc&quot;:&quot;str&quot;,&quot;range&quot;:n or [n,n]},...] )

== Util ==
createmultisig nrequired [&quot;key&quot;,...] ( &quot;address_type&quot; )
deriveaddresses &quot;descriptor&quot; ( range )
estimatesmartfee conf_target ( &quot;estimate_mode&quot; )
getdescriptorinfo &quot;descriptor&quot;
signmessagewithprivkey &quot;privkey&quot; &quot;message&quot;
validateaddress &quot;address&quot;
verifymessage &quot;address&quot; &quot;signature&quot; &quot;message&quot;

== Wallet ==
abandontransaction &quot;txid&quot;
abortrescan
addmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;label&quot; &quot;address_type&quot; )
backupwallet &quot;destination&quot;
bumpfee &quot;txid&quot; ( options )
createwallet &quot;wallet_name&quot; ( disable_private_keys blank &quot;passphrase&quot; avoid_reuse )
dumpprivkey &quot;address&quot;
dumpwallet &quot;filename&quot;
encryptwallet &quot;passphrase&quot;
getaddressesbylabel &quot;label&quot;
getaddressinfo &quot;address&quot;
getbalance ( &quot;dummy&quot; minconf include_watchonly avoid_reuse )
getbalances
getnewaddress ( &quot;label&quot; &quot;address_type&quot; )
getrawchangeaddress ( &quot;address_type&quot; )
getreceivedbyaddress &quot;address&quot; ( minconf )
getreceivedbylabel &quot;label&quot; ( minconf )
gettransaction &quot;txid&quot; ( include_watchonly verbose )
getunconfirmedbalance
getwalletinfo
importaddress &quot;address&quot; ( &quot;label&quot; rescan p2sh )
importmulti &quot;requests&quot; ( &quot;options&quot; )
importprivkey &quot;privkey&quot; ( &quot;label&quot; rescan )
importprunedfunds &quot;rawtransaction&quot; &quot;txoutproof&quot;
importpubkey &quot;pubkey&quot; ( &quot;label&quot; rescan )
importwallet &quot;filename&quot;
keypoolrefill ( newsize )
listaddressgroupings
listlabels ( &quot;purpose&quot; )
listlockunspent
listreceivedbyaddress ( minconf include_empty include_watchonly &quot;address_filter&quot; )
listreceivedbylabel ( minconf include_empty include_watchonly )
listsinceblock ( &quot;blockhash&quot; target_confirmations include_watchonly include_removed )
listtransactions ( &quot;label&quot; count skip include_watchonly )
listunspent ( minconf maxconf [&quot;address&quot;,...] include_unsafe query_options )
listwalletdir
listwallets
loadwallet &quot;filename&quot;
lockunspent unlock ( [{&quot;txid&quot;:&quot;hex&quot;,&quot;vout&quot;:n},...] )
removeprunedfunds &quot;txid&quot;
rescanblockchain ( start_height stop_height )
sendmany &quot;&quot; {&quot;address&quot;:amount} ( minconf &quot;comment&quot; [&quot;address&quot;,...] replaceable conf_target &quot;estimate_mode&quot; )
sendtoaddress &quot;address&quot; amount ( &quot;comment&quot; &quot;comment_to&quot; subtractfeefromamount replaceable conf_target &quot;estimate_mode&quot; avoid_reuse )
sethdseed ( newkeypool &quot;seed&quot; )
setlabel &quot;address&quot; &quot;label&quot;
settxfee amount
setwalletflag &quot;flag&quot; ( value )
signmessage &quot;address&quot; &quot;message&quot;
signrawtransactionwithwallet &quot;hexstring&quot; ( [{&quot;txid&quot;:&quot;hex&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;,&quot;witnessScript&quot;:&quot;hex&quot;,&quot;amount&quot;:amount},...] &quot;sighashtype&quot; )
unloadwallet ( &quot;wallet_name&quot; )
walletcreatefundedpsbt [{&quot;txid&quot;:&quot;hex&quot;,&quot;vout&quot;:n,&quot;sequence&quot;:n},...] [{&quot;address&quot;:amount},{&quot;data&quot;:&quot;hex&quot;},...] ( locktime options bip32derivs )
walletlock
walletpassphrase &quot;passphrase&quot; timeout
walletpassphrasechange &quot;oldpassphrase&quot; &quot;newpassphrase&quot;
walletprocesspsbt &quot;psbt&quot; ( sign &quot;sighashtype&quot; bip32derivs )

== Zmq ==
getzmqnotifications
</code></pre>
<p>You can also type <code>bitcoin-cli help [command]</code> to get even more extensive info on that command. For example:</p>
<pre><code>$ bitcoin-cli help getmininginfo
...
Returns a json object containing mining-related information.
Result:
{                              (json object)
  &quot;blocks&quot; : n,                (numeric) The current block
  &quot;currentblockweight&quot; : n,    (numeric, optional) The block weight of the last assembled block (only present if a block was ever assembled)
  &quot;currentblocktx&quot; : n,        (numeric, optional) The number of block transactions of the last assembled block (only present if a block was ever assembled)
  &quot;difficulty&quot; : n,            (numeric) The current difficulty
  &quot;networkhashps&quot; : n,         (numeric) The network hashes per second
  &quot;pooledtx&quot; : n,              (numeric) The size of the mempool
  &quot;chain&quot; : &quot;str&quot;,             (string) current network name (main, test, regtest)
  &quot;warnings&quot; : &quot;str&quot;           (string) any network and blockchain warnings
}

Examples:
&gt; bitcoin-cli getmininginfo
&gt; curl --user myusername --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;: &quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: []}' -H 'content-type: text/plain;' http://127.0.0.1:8332/
</code></pre>
<blockquote>
<p>:book: <em><strong>What is RPC?</strong></em> <code>bitcoin-cli</code> is just a handy interface that lets you send commands to the <code>bitcoind</code>. More specifically, it's an interface that lets you send RPC (or Remote Procedure Protocol) commands to the <code>bitcoind</code>. Often, the <code>bitcoin-cli</code> command and the RPC command have identical names and interfaces, but some <code>bitcoin-cli</code> commands instead provide shortcuts for more complex RPC requests. Generally, the <code>bitcoin-cli</code> interface is much cleaner and simpler than trying to send RPC commands by hand, using <code>curl</code> or some other method. However, it also has limitations as to what you can ultimately do.</p>
</blockquote>
<h2 id="optional-know-your-bitcoin-info"><a class="header" href="#optional-know-your-bitcoin-info">Optional: Know Your Bitcoin Info</a></h2>
<p>A variety of bitcoin-cli commands can give you additional information on your bitcoin data. The most general ones are:</p>
<p><code>bitcoin-cli -getinfo</code> returns information from different RPCs (user-friendly)</p>
<pre><code class="language-diff">$ bitcoin-cli -getinfo

! Chain: test
Blocks: 1977694
Headers: 1977694
Verification progress: 0.9999993275374796
Difficulty: 1

+ Network: in 0, out 8, total 8
Version: 219900
Time offset (s): 0
Proxy: N/A
Min tx relay fee rate (BTC/kvB): 0.00001000

@@ Wallet: &quot;&quot;@@
Keypool size: 1000
Unlocked until: 0
Transaction fee rate (-paytxfee) (BTC/kvB): 0.00000000

# Balance: 0.02853102

- Warnings: unknown new rules activated (versionbit 28)

</code></pre>
<p>Other commands to get information about blockchain, mining, network, wallet etc.</p>
<pre><code>$ bitcoin-cli getblockchaininfo
$ bitcoin-cli getmininginfo
$ bitcoin-cli getnetworkinfo
$ bitcoin-cli getnettotals
$ bitcoin-cli getwalletinfo
</code></pre>
<p>For example <code>bitcoin-cli getnetworkinfo</code> gives you a variety of information on your setup and its access to various networks:</p>
<pre><code>$ bitcoin-cli getnetworkinfo
{
  &quot;version&quot;: 200000,
  &quot;subversion&quot;: &quot;/Satoshi:0.20.0/&quot;,
  &quot;protocolversion&quot;: 70015,
  &quot;localservices&quot;: &quot;0000000000000408&quot;,
  &quot;localservicesnames&quot;: [
    &quot;WITNESS&quot;,
    &quot;NETWORK_LIMITED&quot;
  ],
  &quot;localrelay&quot;: true,
  &quot;timeoffset&quot;: 0,
  &quot;networkactive&quot;: true,
  &quot;connections&quot;: 10,
  &quot;networks&quot;: [
    {
      &quot;name&quot;: &quot;ipv4&quot;,
      &quot;limited&quot;: false,
      &quot;reachable&quot;: true,
      &quot;proxy&quot;: &quot;&quot;,
      &quot;proxy_randomize_credentials&quot;: false
    },
    {
      &quot;name&quot;: &quot;ipv6&quot;,
      &quot;limited&quot;: false,
      &quot;reachable&quot;: true,
      &quot;proxy&quot;: &quot;&quot;,
      &quot;proxy_randomize_credentials&quot;: false
    },
    {
      &quot;name&quot;: &quot;onion&quot;,
      &quot;limited&quot;: false,
      &quot;reachable&quot;: true,
      &quot;proxy&quot;: &quot;127.0.0.1:9050&quot;,
      &quot;proxy_randomize_credentials&quot;: true
    }
  ],
  &quot;relayfee&quot;: 0.00001000,
  &quot;incrementalfee&quot;: 0.00001000,
  &quot;localaddresses&quot;: [
    {
      &quot;address&quot;: &quot;45.79.111.171&quot;,
      &quot;port&quot;: 18333,
      &quot;score&quot;: 1
    },
    {
      &quot;address&quot;: &quot;2600:3c01::f03c:92ff:fecc:fdb7&quot;,
      &quot;port&quot;: 18333,
      &quot;score&quot;: 1
    },
    {
      &quot;address&quot;: &quot;4wrr3ktm6gl4sojx.onion&quot;,
      &quot;port&quot;: 18333,
      &quot;score&quot;: 4
    }
  ],
  &quot;warnings&quot;: &quot;Warning: unknown new rules activated (versionbit 28)&quot;
}
</code></pre>
<p>Feel free to reference any of these and to use &quot;bitcoin-cli help&quot; if you want more information on what any of them do.</p>
<h2 id="summary-knowing-your-bitcoin-setup"><a class="header" href="#summary-knowing-your-bitcoin-setup">Summary: Knowing Your Bitcoin Setup</a></h2>
<p>The <code>~/.bitcoin</code> directory contains all of your files, while <code>bitcoin-cli help</code> and a variety of info commands can be used to get more information on how your setup and Bitcoin work.</p>
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What's Next?</a></h2>
<p>Continue &quot;Understanding Your Bitcoin Setup&quot; with <a href="03_3_Setting_Up_Your_Wallet.html">§3.3: Setting Up Your Wallet</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-using-command-line-variables"><a class="header" href="#interlude-using-command-line-variables">Interlude: Using Command-Line Variables</a></h1>
<p>The previous section demonstrated a number of command-line commands used without obfuscation or interference. However, that's often not the best way to run Bitcoin from the command line. Because you're dealing with long, complex, and unreadable variables, it's easy to make a mistake if you're copying those variables around (or, satoshi forfend, if you're typing them in by hand). Because those variables can mean the difference between receiving and losing real money, you don't <em>want</em> to make mistakes. For these reasons, we strongly suggest using command-line variables to save addresses, signatures, or other long strings of information whenever it's reasonable to do so.</p>
<p>If you're using <code>bash</code>, you can save information to a variable like this:</p>
<pre><code>$ VARIABLE=$(command)
</code></pre>
<p>That's a simple command substitution, the equivalent to <code>VARIABLE=`command` </code>. The command inside the parentheses is run, then assigned to the VARIABLE.</p>
<p>To create a new address would then look like this:</p>
<pre><code>$ unset NEW_ADDRESS_1
$ NEW_ADDRESS_1=$(bitcoin-cli getnewaddress &quot;&quot; legacy)
</code></pre>
<p>These commands clear the NEW_ADDRESS_1 variable, just to be sure, then fill it with the results of the <code>bitcoin-cli getnewaddress</code> command.</p>
<p>You can then use your shell's <code>echo</code> command to look at your (new) address:</p>
<pre><code>$ echo $NEW_ADDRESS_1
mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE
</code></pre>
<p>Because you have your address in a variable, you can now easily sign a message for that address, without worrying about mistyping the address. You'll of course save that signature into a variable too!</p>
<pre><code>$ NEW_SIG_1=$(bitcoin-cli signmessage $NEW_ADDRESS_1 &quot;Hello, World&quot;)
$ echo $NEW_SIG_1
IPYIzgj+Rg4bxDwCyoPiFiNNcxWHYxgVcklhmN8aB2XRRJqV731Xu9XkfZ6oxj+QGCRmTe80X81EpXtmGUpXOM4=
</code></pre>
<p>The rest of this tutorial will use this style of saving information to variables when it's practical.</p>
<blockquote>
<p>:book: <em><strong>When is it not practical to use command-line variables?</strong></em> Command-line variables aren't practical if you need to use the information somewhere other than on the command line. For example, saving your signature may not actually be useful if you're just going to have to send it to someone else in an email. In addition, some future commands will output JSON objects instead of simple information, and variables can't be used to capture that information ... at least not without a <em>little</em> more work.</p>
</blockquote>
<h2 id="summary-using-command-line-variables"><a class="header" href="#summary-using-command-line-variables">Summary: Using Command-Line Variables</a></h2>
<p>Shell variables can be used to hold long Bitcoin strings, minimizing the chances of mistakes.</p>
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What's Next?</a></h2>
<p>Continue &quot;Understanding Your Bitcoin Setup&quot; with <a href="03_4_Receiving_a_Transaction.html">§3.4: Receiving a Transaction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-setting-up-your-wallet"><a class="header" href="#33-setting-up-your-wallet">3.3: Setting Up Your Wallet</a></h1>
<p>You're now ready to start working with Bitcoin. To begin with, you'll need to create a wallet for sending and receiving funds.</p>
<h2 id="create-a-wallet"><a class="header" href="#create-a-wallet">Create a Wallet</a></h2>
<blockquote>
<p>:warning: <strong>VERSION WARNING:</strong> Newer versions of Bitcoin Core, starting with v0.21.0, will no longer automatically create a default wallet on startup. So, you will need to manually create one. But if you're running an older version of Bitcoin Core, a new wallet has already been created for you, in which case you can skip ahead to <a href="03_3_Setting_Up_Your_Wallet.html#create-an-address">Create an Address</a>.</p>
</blockquote>
<p>The first thing you need to do is create a new wallet, which can be done with the <code>bitcoin-cli createwallet</code> command. By creating a new wallet, you'll be creating your public-private key pair. Your public key is the source from which your addresses will be created, and your private key is what will allow you to spend any funds you receive into your addresses. Bitcoin Core will automatically save that information into a <code>wallet.dat</code> file in your <code>~/.bitcoin/testnet3/wallets</code> directory.</p>
<p>If you check your <code>wallets</code> directory, you'll see that it's currently empty.</p>
<pre><code>$ ls ~/.bitcoin/testnet3/wallets
$
</code></pre>
<p>Although Bitcoin Core won't create a new wallet for you, it will still load a top-level unnamed (&quot;&quot;) wallet on startup by default. You can take advantage of this by creating a new unnamed wallet.</p>
<pre><code>$ bitcoin-cli createwallet &quot;&quot;
{
  &quot;name&quot;: &quot;&quot;,
  &quot;warning&quot;: &quot;&quot;
}
</code></pre>
<p>Now, your <code>wallets</code> directory should be populated.</p>
<pre><code>$ ls ~/.bitcoin/testnet3/wallets
database  db.log  wallet.dat
</code></pre>
<blockquote>
<p>:book: <em><strong>What is a Bitcoin wallet?</strong></em> A Bitcoin wallet is the digital equivalent of a physical wallet on the Bitcoin network. It stores information on the amount of bitcoins you have and where it's located (addresses), as well as the ways you can use to spend it. Spending physical money is intuitive, but to spend bitcoins users need to provide the correct <em>private key</em>. We will explain this in more detail throughout the course, but what you should know for now is that this public-private key dynamic is part of what makes Bitcoin secure and trustless. Your key pair information is saved in the <code>wallet.dat</code> file, in addition to data about preferences and transactions. For the most part, you won't have to worry about that private key: <code>bitcoind</code> will use it when it's needed. However, this makes the <code>wallet.dat</code> file extremely important: if you lose it, you lose your private keys, and if you lose your private keys, you lose your funds!</p>
</blockquote>
<p>Sweet, now you have a Bitcoin wallet. But a wallet will be of little use for receiving bitcoins if you don't create an address first.</p>
<h2 id="create-an-address"><a class="header" href="#create-an-address">Create an Address</a></h2>
<p>The next thing you need to do is create an address for receiving payments. This is done with the <code>bitcoin-cli getnewaddress</code> command. Remember that if you want more information on this command, you should type <code>bitcoin-cli help getnewaddress</code>. Currently, there are three types of addresses: <code>legacy</code> and the two types of SegWit address, <code>p2sh-segwit</code> and <code>bech32</code>. If you do not otherwise specify, you'll get the default, which is currently <code>bech32</code>.</p>
<p>However, for the next few sections we're instead going to be using <code>legacy</code> addresses, both because <code>bitcoin-cli</code> had some teething problems with its early versions of SegWit addresses, and because other people might not be able to send to <code>bech32</code> addresses. This is all unlikely to be a problem for you now, but for the moment we want to get your started with transaction examples that are (mostly) guaranteed to work.</p>
<p>First, restart <code>bitcoind</code> so your new unnamed wallet is set as default and automatically loaded.</p>
<pre><code>$ bitcoin-cli stop
Bitcoin Core stopping # wait a minute so it stops completely
$ bitcoind -daemon
Bitcoin Core starting # wait a minute so it starts completely
</code></pre>
<p>You can now create an address. You can require <code>legacy</code> address either with the second argument to <code>getnewaddress</code> or with the named <code>addresstype</code> argument.</p>
<pre><code>$ bitcoin-cli getnewaddress -addresstype legacy
moKVV6XEhfrBCE3QCYq6ppT7AaMF8KsZ1B
</code></pre>
<p>Note that this address begins with an &quot;m&quot; (or sometimes an &quot;n&quot;) to signify a testnet Legacy address. It would be a &quot;2&quot; for a P2SH address or a &quot;tb1&quot; for a Bech32 address.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> The equivalent mainnet address would start with a &quot;1&quot; (for Legacy), &quot;3&quot; (for P2SH), or &quot;bc1&quot; (for Bech32).</p>
</blockquote>
<p>Take careful note of the address. You'll need to give it to whomever will be sending you funds.</p>
<blockquote>
<p>:book: <em><strong>What is a Bitcoin address?</strong></em> A Bitcoin address is literally where you receive money. It's like an email address, but for funds. Technically, it's a public key, though different address schemes adjust that in different ways. However unlike an email address, a Bitcoin address should be considered single use: use it to receive funds just <em>once</em>. When you want to receive funds from someone else or at some other time, generate a new address. This is suggested in large part to improve your privacy. The whole blockchain is immutable, which means that explorers can look at long chains of transactions over time, making it possible to statistically determine who you and your contacts are, no matter how careful you are. However, if you keep reusing the same address, then this becomes even easier. By creating your first Bitcoin address, you've also begun to fill in your Bitcoin wallet. More precisely, you've begun to fill the <code>wallet.dat</code> file in your <code>~/.bitcoin/testnet3 /wallets</code> directory.</p>
</blockquote>
<p>With a single address in hand, you could jump straight to the next section and begin receiving funds. However, before we get there, we're going to briefly discuss the other sorts of addresses that you'll meet in the future and talk about a few other wallet commands that you might want to use in the future.</p>
<h3 id="knowing-your-bitcoin-addresses"><a class="header" href="#knowing-your-bitcoin-addresses">Knowing Your Bitcoin Addresses</a></h3>
<p>There are three types of Bitcoin addresses that you can create with the <code>getnewaddress</code> RPC command. You'll be using a <code>legacy</code> (P2PKH) address here, while you'll move over to a SegWit (P2SH-SegWit) or Bech32 address in <a href="04_6_Creating_a_Segwit_Transaction.html">§4.6: Creating a Segwit Transaction</a>.</p>
<p>As noted above, the foundation of a Bitcoin address is a public key: someone sends funds to your public key, and then you use your private key to redeem it. Easy? Except putting your public key out there isn't entirely secure. At the moment, if someone has your public key, then they can't retrieve your private key (and thus your funds); that's the basis of cryptography, which uses a trap-door function to ensure that you can only go from private to public key, and not vice-versa. But the problem is that we don't know what the future might bring. Except we do know that cryptography systems eventually get broken by the relentless advance of technology, so it's better not to put raw public keys on the 'net, to future-proof your transactions.</p>
<p>Classic Bitcoin transactions created P2PKH addresses that added an additional cryptographic step to protect public keys.</p>
<blockquote>
<p>:book: <em><strong>What is a Legacy (P2PKH) address?</strong></em> This is a Legacy address of the sort used by the early Bitcoin network. We'll be using it in examples for the next few sections. It's called a Pay to PubKey Hash (or P2PKH) address because the address is a 160-bit hash of a public key. Using a hash of your public key as your address creates a two-step process where to spend funds you need to reveal both the private key and the public key, and it increases future security accordingly. This sort of address remains important for receiving funds from people with out-of-date wallet software.</p>
</blockquote>
<p>As described more fully in <a href="04_6_Creating_a_Segwit_Transaction.html">§4.6: Creating a Segwit Transaction</a>, the Block Size Wars of the late '10s resulted in a new sort of address: SegWit. This is the preferred sort of address currently, and should be fully integrated into Bitcoin-Core at this point, but nonetheless we're saving it for §4.6.</p>
<p>SegWit simply means &quot;segregated witness&quot; and it's a way of separating the transaction signatures out from the rest of the transaction to reduce transaction size. Some SegWit addresses will sneak into some of our examples prior to §4.6 as change addresses, which you'll see as addresses that begin with &quot;tb&quot;. This is fine because the <code>bitcoin-cli</code> entirely supports their usage. But we won't use them otherwise.</p>
<p>There are two addresses of this sort:</p>
<blockquote>
<p>:book: <em><strong>What is a P2SH-SegWit (aka Nested SegWit) address?</strong></em> This is the first generation of SegWit. It wraps the SegWit address in a Script hash to ensure backward compatibility. The result creates transactions that are about 25%+ smaller (with corresponding reductions in transaction fees). </p>
</blockquote>
<blockquote>
<p>:book: <em><strong>What is a Bech32 (aka Native SegWit, aka P2WPKH) address?</strong></em> This is the second generation of SegWit. It's fully described in <a href="https://en.bitcoin.it/wiki/BIP_0173">BIP 173</a>. It creates transactions that are even smaller but more notably also has some advantages in creating addresses that are less prone to human error and have some implicit error-correction beyond that. It is <em>not</em> backward compatible like P2SH-SegWit was, and so some people may not be able to send to it.</p>
</blockquote>
<p>There are other sorts of Bitcoin addresses, such as P2PK (which paid to a bare public key, and is deprecated because of its future insecurity) and P2SH (which pays to a Script Hash, and which is used by the first-generation Nested SegWit addresses; we'll meet it more fully in a few chapters).</p>
<h2 id="optional-sign-a-message"><a class="header" href="#optional-sign-a-message">Optional: Sign a Message</a></h2>
<p>Sometimes you'll need to prove that you control a Bitcoin address (or rather, that you control its private key). This is important because it lets people know that they're sending funds to the right person. This can be done by creating a signature with the <code>bitcoin-cli signmessage</code> command, in the form <code>bitcoin-cli signmessage [address] [message]</code>. For example:</p>
<pre><code>$ bitcoin-cli signmessage &quot;moKVV6XEhfrBCE3QCYq6ppT7AaMF8KsZ1B&quot; &quot;Hello, World&quot;
HyIP0nzdcH12aNbQ2s2rUxLwzG832HxiO1vt8S/jw+W4Ia29lw6hyyaqYOsliYdxne70C6SZ5Utma6QY/trHZBI=
</code></pre>
<p>You'll get the signature as a return.</p>
<blockquote>
<p>:book: <em><strong>What is a signature?</strong></em> A digital signature is a combination of a message and a private key that can then be unlocked with a public key. Since there's a one-to-one correspendence between the elements of a keypair, unlocking with a public key proves that the signer controlled the corresponding private key.</p>
</blockquote>
<p>Another person can then use the <code>bitcoin-cli verifymessage</code> command to verify the signature. He inputs the address in question, the signature, and the message:</p>
<pre><code>$ bitcoin-cli verifymessage &quot;moKVV6XEhfrBCE3QCYq6ppT7AaMF8KsZ1B&quot; &quot;HyIP0nzdcH12aNbQ2s2rUxLwzG832HxiO1vt8S/jw+W4Ia29lw6hyyaqYOsliYdxne70C6SZ5Utma6QY/trHZBI=&quot; &quot;Hello, World&quot;
true
</code></pre>
<p>If they all match up, then the other person knows that he can safely transfer funds to the person who signed the message by sending to the address.</p>
<p>If some black hat was making up signatures, this would instead produce a negative result:</p>
<pre><code>$ bitcoin-cli verifymessage &quot;FAKEV6XEhfrBCE3QCYq6ppT7AaMF8KsZ1B&quot; &quot;HyIP0nzdcH12aNbQ2s2rUxLwzG832HxiO1vt8S/jw+W4Ia29lw6hyyaqYOsliYdxne70C6SZ5Utma6QY/trHZBI=&quot; &quot;Hello, World&quot;
error code: -3
error message:
Invalid address
</code></pre>
<h2 id="optional-dump-your-wallet"><a class="header" href="#optional-dump-your-wallet">Optional: Dump Your Wallet</a></h2>
<p>It might seem dangerous having all of your irreplaceable private keys in a single file. That's what <code>bitcoin-cli dumpwallet</code> is for. It lets you make a copy of your wallet.dat:</p>
<pre><code>$ bitcoin-cli dumpwallet ~/mywallet.txt
</code></pre>
<p>The <code>mywallet.txt</code> file in your home directory will have a long list of private keys, addresses, and other information. Mind you, you'd never want to put this data out in a plain text file on a Bitcoin setup with real funds!</p>
<p>You can then recover it with <code>bitcoin-cli importwallet</code>.</p>
<pre><code>$ bitcoin-cli importwallet ~/mywallet.txt
</code></pre>
<p>But note this requires an unpruned node!</p>
<pre><code>$ bitcoin-cli importwallet ~/mywallet.txt
error code: -4
error message:
Importing wallets is disabled when blocks are pruned
</code></pre>
<h2 id="optional-view-your-private-keys"><a class="header" href="#optional-view-your-private-keys">Optional: View Your Private Keys</a></h2>
<p>Sometimes, you might want to actually look at the private keys associated with your Bitcoin addresses. Perhaps you want to be able to sign a message or spend bitcoins from a different machine. Perhaps you just want to back up certain important private keys. You can also do this with your dump file, since it's human readable.</p>
<pre><code>$ bitcoin-cli dumpwallet ~/mywallet.txt
{
  &quot;filename&quot;: &quot;/home/standup/mywallet.txt&quot;
}
</code></pre>
<p>More likely, you just want to look at the private key associated with a specific address. This can be done with the <code>bitcoin-cli dumpprivkey</code> command.</p>
<pre><code>$ bitcoin-cli dumpprivkey &quot;moKVV6XEhfrBCE3QCYq6ppT7AaMF8KsZ1B&quot;
cTv75T4B3NsG92tdSxSfzhuaGrzrmc1rJjLKscoQZXqNRs5tpYhH
</code></pre>
<p>You can then save that key somewhere safe, preferably somewhere not connected to the internet.</p>
<p>You can also import any private key, from a wallet dump or an individual key dump, as follows:</p>
<pre><code>$ bitcoin-cli importprivkey cW4s4MdW7BkUmqiKgYzSJdmvnzq8QDrf6gszPMC7eLmfcdoRHtHh
</code></pre>
<p>Again, expect this to require an unpruned node. Expect this to take a while, as <code>bitcoind</code> needs to reread all past transactions, to see if there are any new ones that it should pay attention to.</p>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> Many modern wallets prefer <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">mnemonic codes</a> to generate the seeds necessary to create the private keys. This methodology is not used <code>bitcoin-cli</code>, so you won't be able to generate handy word lists to remember your private keys.</p>
</blockquote>
<p><em>You've been typing that Bitcoin address you generated a <em>lot</em>, while you were signing messages and now dumping keys. If you think it's a pain, we agree. It's also prone to errors, a topic that we'll address in the very next section.</em></p>
<h2 id="summary-setting-up-your-wallet"><a class="header" href="#summary-setting-up-your-wallet">Summary: Setting Up Your Wallet</a></h2>
<p>You need to create an address to receive funds. Your address is stored in a wallet, which you can back up. You can also do lots more with an address, like dumping its private key or using it to sign messages. But really, creating that address is <em>all</em> you need to do in order to receive Bitcoin funds.</p>
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What's Next?</a></h2>
<p>Step back from &quot;Understanding Your Bitcoin Setup&quot; with <a href="03_3__Interlude_Using_Command-Line_Variables.html">Interlude: Using Command-Line Variables</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-receiving-a-transaction"><a class="header" href="#34-receiving-a-transaction">3.4: Receiving a Transaction</a></h1>
<p>You're now ready to receive some money at the new address you set up.</p>
<h2 id="get-some-money"><a class="header" href="#get-some-money">Get Some Money</a></h2>
<p>To do anything more, you need to get some money. On testnet this is done through faucets. Since the money is all pretend, you just go to a faucet, request some money, and it will be sent over to you. We suggest using the faucet at https://testnet-faucet.mempool.co/, https://bitcoinfaucet.uo1.net/, or https://testnet.coinfaucet.eu/en/. If they're not available for some reason, search for &quot;bitcoin testnet faucet&quot;, and you should find others.</p>
<p>To use a faucet, you'll usually need to go to a URL and copy and paste in your address. Note that this is one of those cases where you won't be able to use command-line variables, alas. Afterward, a transaction will be created that sends money from the faucet to you.</p>
<blockquote>
<p>:book: <em><strong>What is a transaction?</strong></em> A transaction is a bitcoin exchange. The owner of some bitcoins uses his private key to access those coins, then locks the transaction using the recipient's public key.</p>
</blockquote>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> Sadly, there are no faucets in real life. If you were playing on the mainnet, you'd need to go and actually buy bitcoins at a bitcoin exchange or ATM, or you'd need to get someone to send them to you. Testnet life is much easier.</p>
</blockquote>
<h2 id="verify-your-money"><a class="header" href="#verify-your-money">Verify Your Money</a></h2>
<p>After you've requested your money, you should be able to verify it with the <code>bitcoin-cli getbalance</code> command:</p>
<pre><code>$ bitcoin-cli getbalance
0.00000000
</code></pre>
<p>But wait, there's no balance yet!?</p>
<p>Welcome to the world of Bitcoin latency. The problem is that your transaction hasn't yet been recorded in a block!</p>
<blockquote>
<p>:book: <em><strong>What is a block?</strong></em> Transactions are transmitted across the network and gathered into blocks by miners. These blocks are secured with a mathematical proof-of-work, which proves that computing power has been expended as part of the block creation. It's that proof-of-work (multiplied over many blocks, each built atop the last) that ultimately keeps Bitcoin secure.</p>
</blockquote>
<blockquote>
<p>:book: <em><strong>What is a miner?</strong></em> A miner is a participant of the Bitcoin network who works to create blocks. It's a paying job: when a miner successfully creates a block, he is paid a one-time reward plus the fees for the transactions in his block. Mining is big business. Miners tend to run on special hardware, accelerated in ways that make it more likely that they'll be able to create blocks. They also tend to be part of mining pools, where the miners all agree to share out the rewards when one of them successfully creates a block.</p>
</blockquote>
<p>Fortunately, <code>bitcoin-cli getunconfirmedbalance</code> should still show your updated balance as long as the initial transaction has been created:</p>
<pre><code>$ bitcoin-cli getunconfirmedbalance
0.01010000
</code></pre>
<p>If that's still showing a zero too, you're probably moving through this tutorial too fast. Wait a second. The coins should show up unconfirmed, then rapidly move to confirmed. Do note that a coin can move from unconfirmedbalance to confirmedbalance almost immediately, so make sure you check both. However, if your <code>getbalance</code> and your <code>getunconfirmedbalance</code> both still show zero in ten minutes, then there's probably something wrong with the faucet, and you'll need to pick another.</p>
<h3 id="gain-confidence-in-your-money"><a class="header" href="#gain-confidence-in-your-money">Gain Confidence in Your Money</a></h3>
<p>You can use <code>bitcoin-cli getbalance &quot;*&quot; [n]</code>, where you replace <code>[n]</code> with an integer, to see if a confirmed balance is 'n' blocks deep.</p>
<blockquote>
<p>:book: <em><strong>What is block depth?</strong></em> After a block is built and confirmed, another block is built on top of it, and another ... Because this is a stochastic process, there's some chance for reversal when a block is still new. Thus, a block has to be buried several blocks deep in a chain before you can feel totally confident in your funds. Each of those blocks tends to be built in an average of 10 minutes ... so it usually takes about an hour for a confirmed transaction to receive six blocks deep, which is the measure for full confidence in Bitcoin.</p>
</blockquote>
<p>The following shows that our transactions have been confirmed one time, but not twice:</p>
<pre><code>$  bitcoin-cli getbalance &quot;*&quot; 1
0.01010000
$  bitcoin-cli getbalance &quot;*&quot; 2
0.00000000
</code></pre>
<p>Obviously, every ten minutes or so this depth will increase.</p>
<p>Of course, on the testnet, no one is that worried about how reliable your funds are. You'll be able to spend your money as soon as it's confirmed.</p>
<h2 id="verify-your-wallet"><a class="header" href="#verify-your-wallet">Verify Your Wallet</a></h2>
<p>The <code>bitcoin-cli getwalletinfo</code> command gives you more information on the balance of your wallet:</p>
<pre><code>$ bitcoin-cli getwalletinfo
{
  &quot;walletname&quot;: &quot;&quot;,
  &quot;walletversion&quot;: 169900,
  &quot;balance&quot;: 0.01010000,
  &quot;unconfirmed_balance&quot;: 0.00000000,
  &quot;immature_balance&quot;: 0.00000000,
  &quot;txcount&quot;: 2,
  &quot;keypoololdest&quot;: 1592335137,
  &quot;keypoolsize&quot;: 999,
  &quot;hdseedid&quot;: &quot;fdea8e2630f00d29a9d6ff2af7bf5b358d061078&quot;,
  &quot;keypoolsize_hd_internal&quot;: 1000,
  &quot;paytxfee&quot;: 0.00000000,
  &quot;private_keys_enabled&quot;: true,
  &quot;avoid_reuse&quot;: false,
  &quot;scanning&quot;: false
}
</code></pre>
<h2 id="discover-your-transaction-id"><a class="header" href="#discover-your-transaction-id">Discover Your Transaction ID</a></h2>
<p>Your money came into your wallet via a transaction. You can discover that transactionid (txid) with the <code>bitcoin-cli listtransactions</code> command:</p>
<pre><code>$ bitcoin-cli listtransactions
[
  {
    &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
    &quot;category&quot;: &quot;receive&quot;,
    &quot;amount&quot;: 0.01000000,
    &quot;label&quot;: &quot;&quot;,
    &quot;vout&quot;: 1,
    &quot;confirmations&quot;: 1,
    &quot;blockhash&quot;: &quot;00000000000001753b24411d0e4726212f6a53aeda481ceff058ffb49e1cd969&quot;,
    &quot;blockheight&quot;: 1772396,
    &quot;blockindex&quot;: 73,
    &quot;blocktime&quot;: 1592600085,
    &quot;txid&quot;: &quot;8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9&quot;,
    &quot;walletconflicts&quot;: [
    ],
    &quot;time&quot;: 1592599884,
    &quot;timereceived&quot;: 1592599884,
    &quot;bip125-replaceable&quot;: &quot;no&quot;
  },
  {
    &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
    &quot;category&quot;: &quot;receive&quot;,
    &quot;amount&quot;: 0.00010000,
    &quot;label&quot;: &quot;&quot;,
    &quot;vout&quot;: 0,
    &quot;confirmations&quot;: 1,
    &quot;blockhash&quot;: &quot;00000000000001753b24411d0e4726212f6a53aeda481ceff058ffb49e1cd969&quot;,
    &quot;blockheight&quot;: 1772396,
    &quot;blockindex&quot;: 72,
    &quot;blocktime&quot;: 1592600085,
    &quot;txid&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
    &quot;walletconflicts&quot;: [
    ],
    &quot;time&quot;: 1592599938,
    &quot;timereceived&quot;: 1592599938,
    &quot;bip125-replaceable&quot;: &quot;no&quot;
  }
]

</code></pre>
<p>This shows two transactions (<code>8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9</code>) and (<code>ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36</code>) for a specific amount (<code>0.01000000</code> and <code>0.00010000</code>), which were both received (<code>receive</code>) by the same address in our wallet (<code>mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE</code>). That's bad key hygeine, by the way: you should use a new address for every single Bitcoin you ever receive. In this case, we got impatient because the first faucet didn't seem to be working.</p>
<p>You can access similar information with the <code>bitcoin-cli listunspent</code> command, but it only shows the transactions for the money that you haven't spent. These are called UTXOs, and will be vitally important when you're sending money back out into the Bitcoin world:</p>
<pre><code>$ bitcoin-cli listunspent
[
  {
    &quot;txid&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9141b72503639a13f190bf79acf6d76255d772360b788ac&quot;,
    &quot;amount&quot;: 0.00010000,
    &quot;confirmations&quot;: 1,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/1']02fd5740996d853ea51a6904cf03257fc11204b0179f344c49739ec5b20b39c9ba)#62rud39c&quot;,
    &quot;safe&quot;: true
  },
  {
    &quot;txid&quot;: &quot;8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9&quot;,
    &quot;vout&quot;: 1,
    &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9141b72503639a13f190bf79acf6d76255d772360b788ac&quot;,
    &quot;amount&quot;: 0.01000000,
    &quot;confirmations&quot;: 1,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/1']02fd5740996d853ea51a6904cf03257fc11204b0179f344c49739ec5b20b39c9ba)#62rud39c&quot;,
    &quot;safe&quot;: true
  }
]
</code></pre>
<p>Note that bitcoins are not just a homogeneous mess of cash jammed into your pocket. Each individual transaction that you receive or that you send is placed into the immutable blockchain ledger, in a block. You can see these individual transactions when you look at your unspent money. This means that bitcoin spending isn't quite as anonymous as you'd think. Though the addresses are fairly private, transactions can be examined as they go in and out of addresses. This makes privacy vulnerable to statistical analysis. It also introduces some potential non-fungibility to bitcoins, as you can track back through series of transactions, even if you can't track a specific &quot;bitcoin&quot;.</p>
<blockquote>
<p>:book: <em><strong>Why are all of these bitcoin amounts in fractions?</strong></em> Bitcoins are produced slowly, and so there are relatively few in circulation. As a result, each bitcoin over on the mainnet is worth quite a bit (~ $9,000 at the time of this writing). This means that people usually work in fractions. In fact, the .0101 in Testnet coins would be worth about $100 if they were on the mainnet. For this reason, names have appeared for smaller amounts of bitcoins, including millibitcoins or mBTCs (one-thousandth of a bitcoin), microbitcoins or bits or μBTCs (one-millionth of a bitcoin), and satoshis (one hundred millionth of a bitcoin).</p>
</blockquote>
<h2 id="examine-your-transaction"><a class="header" href="#examine-your-transaction">Examine Your Transaction</a></h2>
<p>You can get more information on a transaction with the <code>bitcoin-cli gettransaction</code> command:</p>
<pre><code>$ bitcoin-cli gettransaction &quot;8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9&quot;
{
  &quot;amount&quot;: 0.01000000,
  &quot;confirmations&quot;: 1,
  &quot;blockhash&quot;: &quot;00000000000001753b24411d0e4726212f6a53aeda481ceff058ffb49e1cd969&quot;,
  &quot;blockheight&quot;: 1772396,
  &quot;blockindex&quot;: 73,
  &quot;blocktime&quot;: 1592600085,
  &quot;txid&quot;: &quot;8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9&quot;,
  &quot;walletconflicts&quot;: [
  ],
  &quot;time&quot;: 1592599884,
  &quot;timereceived&quot;: 1592599884,
  &quot;bip125-replaceable&quot;: &quot;no&quot;,
  &quot;details&quot;: [
    {
      &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
      &quot;category&quot;: &quot;receive&quot;,
      &quot;amount&quot;: 0.01000000,
      &quot;label&quot;: &quot;&quot;,
      &quot;vout&quot;: 1
    }
  ],
  &quot;hex&quot;: &quot;0200000000010114d04977d1b0137adbf51dd5d79944b9465a2619f3fa7287eb69a779977bf5800100000017160014e85ba02862dbadabd6d204fcc8bb5d54658c7d4ffeffffff02df690f000000000017a9145c3bfb36b03f279967977ca9d1e35185e39917788740420f00000000001976a9141b72503639a13f190bf79acf6d76255d772360b788ac0247304402201e74bdfc330fc2e093a8eabe95b6c5633c8d6767249fa25baf62541a129359c202204d462bd932ee5c15c7f082ad7a6b5a41c68addc473786a0a9a232093fde8e1330121022897dfbf085ecc6ad7e22fc91593414a845659429a7bbb44e2e536258d2cbc0c270b1b00&quot;
}
</code></pre>
<p>The <code>gettransaction</code> command will detail transactions that are in your wallet, such as this one, that was sent to us.</p>
<p>Note that <code>gettransaction</code> has two optional arguments:</p>
<pre><code>$ bitcoin-cli help gettransaction
gettransaction &quot;txid&quot; ( include_watchonly verbose )

Get detailed information about in-wallet transaction &lt;txid&gt;

Arguments:
1. txid                 (string, required) The transaction id
2. include_watchonly    (boolean, optional, default=true for watch-only wallets, otherwise false) Whether to include watch-only addresses in balance calculation and details[]
3. verbose              (boolean, optional, default=false) Whether to include a `decoded` field containing the decoded transaction (equivalent to RPC decoderawtransaction)
</code></pre>
<p>By setting these two true or false, we can choose to include watch-only addresses in the output (which we don't care about) or look at more verbose output (which we do).</p>
<p>Here's what this data instead looks at when we set <code>include_watchonly</code> to <code>false</code> and <code>verbose</code> to <code>true</code>.</p>
<pre><code>$ bitcoin-cli gettransaction &quot;8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9&quot; false true
{
  &quot;amount&quot;: 0.01000000,
  &quot;confirmations&quot;: 3,
  &quot;blockhash&quot;: &quot;00000000000001753b24411d0e4726212f6a53aeda481ceff058ffb49e1cd969&quot;,
  &quot;blockheight&quot;: 1772396,
  &quot;blockindex&quot;: 73,
  &quot;blocktime&quot;: 1592600085,
  &quot;txid&quot;: &quot;8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9&quot;,
  &quot;walletconflicts&quot;: [
  ],
  &quot;time&quot;: 1592599884,
  &quot;timereceived&quot;: 1592599884,
  &quot;bip125-replaceable&quot;: &quot;no&quot;,
  &quot;details&quot;: [
    {
      &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
      &quot;category&quot;: &quot;receive&quot;,
      &quot;amount&quot;: 0.01000000,
      &quot;label&quot;: &quot;&quot;,
      &quot;vout&quot;: 1
    }
  ],
  &quot;hex&quot;: &quot;0200000000010114d04977d1b0137adbf51dd5d79944b9465a2619f3fa7287eb69a779977bf5800100000017160014e85ba02862dbadabd6d204fcc8bb5d54658c7d4ffeffffff02df690f000000000017a9145c3bfb36b03f279967977ca9d1e35185e39917788740420f00000000001976a9141b72503639a13f190bf79acf6d76255d772360b788ac0247304402201e74bdfc330fc2e093a8eabe95b6c5633c8d6767249fa25baf62541a129359c202204d462bd932ee5c15c7f082ad7a6b5a41c68addc473786a0a9a232093fde8e1330121022897dfbf085ecc6ad7e22fc91593414a845659429a7bbb44e2e536258d2cbc0c270b1b00&quot;,
  &quot;decoded&quot;: {
    &quot;txid&quot;: &quot;8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9&quot;,
    &quot;hash&quot;: &quot;d4ae2b009c43bfe9eba96dcd16e136ceba2842df3d76a67d689fae5975ce49cb&quot;,
    &quot;version&quot;: 2,
    &quot;size&quot;: 249,
    &quot;vsize&quot;: 168,
    &quot;weight&quot;: 669,
    &quot;locktime&quot;: 1772327,
    &quot;vin&quot;: [
      {
        &quot;txid&quot;: &quot;80f57b9779a769eb8772faf319265a46b94499d7d51df5db7a13b0d17749d014&quot;,
        &quot;vout&quot;: 1,
        &quot;scriptSig&quot;: {
          &quot;asm&quot;: &quot;0014e85ba02862dbadabd6d204fcc8bb5d54658c7d4f&quot;,
          &quot;hex&quot;: &quot;160014e85ba02862dbadabd6d204fcc8bb5d54658c7d4f&quot;
        },
        &quot;txinwitness&quot;: [
          &quot;304402201e74bdfc330fc2e093a8eabe95b6c5633c8d6767249fa25baf62541a129359c202204d462bd932ee5c15c7f082ad7a6b5a41c68addc473786a0a9a232093fde8e13301&quot;,
          &quot;022897dfbf085ecc6ad7e22fc91593414a845659429a7bbb44e2e536258d2cbc0c&quot;
        ],
        &quot;sequence&quot;: 4294967294
      }
    ],
    &quot;vout&quot;: [
      {
        &quot;value&quot;: 0.01010143,
        &quot;n&quot;: 0,
        &quot;scriptPubKey&quot;: {
          &quot;asm&quot;: &quot;OP_HASH160 5c3bfb36b03f279967977ca9d1e35185e3991778 OP_EQUAL&quot;,
          &quot;hex&quot;: &quot;a9145c3bfb36b03f279967977ca9d1e35185e399177887&quot;,
          &quot;reqSigs&quot;: 1,
          &quot;type&quot;: &quot;scripthash&quot;,
          &quot;addresses&quot;: [
            &quot;2N1ev1WKevSsdmAvRqZf7JjvDg223tPrVCm&quot;
          ]
        }
      },
      {
        &quot;value&quot;: 0.01000000,
        &quot;n&quot;: 1,
        &quot;scriptPubKey&quot;: {
          &quot;asm&quot;: &quot;OP_DUP OP_HASH160 1b72503639a13f190bf79acf6d76255d772360b7 OP_EQUALVERIFY OP_CHECKSIG&quot;,
          &quot;hex&quot;: &quot;76a9141b72503639a13f190bf79acf6d76255d772360b788ac&quot;,
          &quot;reqSigs&quot;: 1,
          &quot;type&quot;: &quot;pubkeyhash&quot;,
          &quot;addresses&quot;: [
            &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;
          ]
        }
      }
    ]
  }
}
</code></pre>
<p>Now you can see the full information on the transaction, including all of the inputs (&quot;vin&quot;) and all the outputs (&quot;vout). One of the interesting things to note is that although we received .01 BTC in the transaction, another .01010143 was sent to another address. That was probably a change address, a concept that is explored in the next section. It is quite typical for a transaction to have multiple inputs and/or multiple outputs.</p>
<p>There is another command, <code>getrawtransaction</code>, which allows you to look at transactions that are not in your wallet. However, it requires you to have unpruned node and <code>txindex=1</code> in your <code>bitcoin.conf</code> file. Unless you have a serious need for information not in your wallet, it's probably just better to use a Bitcoin explorer for this sort of thing ...</p>
<h2 id="optional-use-a-block-explorer"><a class="header" href="#optional-use-a-block-explorer">Optional: Use a Block Explorer</a></h2>
<p>Even looking at the verbose information for a transaction can be a little intimidating. The main goal of this tutorial is to teach how to deal with raw transactions from the command line, but we're happy to talk about other tools when they're applicable. One of those tools is a block explorer, which you can use to look at transactions from a web browser in a much friendlier format.</p>
<p>Currently, our preferred block explorer is <a href="https://live.blockcypher.com/">https://live.blockcypher.com/</a>.</p>
<p>You can use it to look up transactions for an address:</p>
<p><a href="https://live.blockcypher.com/btc-testnet/address/mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE/">https://live.blockcypher.com/btc-testnet/address/mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE/</a></p>
<p>You can also use it to look at individual transactions:</p>
<p><a href="https://live.blockcypher.com/btc-testnet/tx/8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9/">https://live.blockcypher.com/btc-testnet/tx/8e2ab10cabe9ec04ed438086a80b1ac72558cc05bb206e48fc9a18b01b9282e9/</a></p>
<p>A block explorer doesn't generally provide any more information than a command line look at a raw transaction; it just does a good job of highlighting the important information and putting together the puzzle pieces, including the transaction fees behind a transaction — another concept that we'll be covering in future sections.</p>
<h2 id="summary-receiving-a-transaction"><a class="header" href="#summary-receiving-a-transaction">Summary: Receiving a Transaction</a></h2>
<p>Faucets will give you money on the testnet. They come in as raw transactions, which can be examined with <code>gettransaction</code> or a block explorer. Once you've receive a transaction, you can see it in your balance and your wallet.</p>
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What's Next?</a></h2>
<p>For a deep dive into how addresses are described, so that they can be transferred or made into parts of a multi-signature, see <a href="03_5_Understanding_the_Descriptor.html">§3.5: Understanding the Descriptor</a>.</p>
<p>But if that's too in-depth, continue on to <a href="04_0_Sending_Bitcoin_Transactions.html">Chapter Four: Sending Bitcoin Transactions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="35-understanding-the-descriptor"><a class="header" href="#35-understanding-the-descriptor">3.5: Understanding the Descriptor</a></h1>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> This section has been recently added to the course and is an early draft that may still be awaiting review. Caveat reader.</p>
</blockquote>
<p>You may have noticed a weird <code>desc:</code> field in the <code>listunspent</code> command of the previous section. Here's what's all about (and how it can be used to transfer addresses).</p>
<blockquote>
<p>:warning: <strong>VERSION WARNING:</strong> This is an innovation from Bitcoin Core v 0.17.0 that had continued to be expanded through Bitcoin Core 0.20.0. Most of the commands in this section are from 0.17.0, but the updated <code>importmulti</code> that support descriptors is from 0.18.0.</p>
</blockquote>
<h2 id="know-about-transferring-addresses"><a class="header" href="#know-about-transferring-addresses">Know about Transferring Addresses</a></h2>
<p>Most of this course presumes that you're working entirely from a single node where you manage your own wallet, sending and receiving payments with the addresses created by that wallet. However, that's not necessarily how the larger Bitcoin ecosystem works. There, you're more likely to be moving addresses between wallets and even setting up wallets to watch over funds controlled by different wallets. </p>
<p>That's where descriptors come in. They're most useful if you're interacting with software <em>other</em> than Bitcoin Core, and really need to lean on this sort of compatibility function: see <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/06_1_Sending_a_Transaction_to_a_Multisig.md">§6.1</a> for a real-world example of how having the capability of descriptors is critical.</p>
<p>Moving addresses between wallets used to focus on <code>xpub</code> and <code>xprv</code>, and those are still supported. </p>
<blockquote>
<p>:book: <em><strong>What is xprv?</strong></em> An extended private key. This is the combination of a private key and a chain code. It's a private key that a whole sequence of children private keys can be derived from.</p>
</blockquote>
<blockquote>
<p>:book: <em><strong>What is xpub?</strong></em> An extended public key. This is the combination of a public key and a chain code. It's a public key that a whole sequence of children public keys can be derived from.</p>
</blockquote>
<p>The fact that you can have a &quot;whole sequence of children ... keys&quot; reveals the fact that &quot;xpub&quot; and &quot;xprv&quot; aren't standard keys like we've been talking about so far. They're instead hierarchical keys that can be used to create whole families of keys, built on the idea of HD Wallets.</p>
<blockquote>
<p>:book: <em><strong>What is an HD Wallet?</strong></em> Most modern wallets are built on <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32: Hierarchical Deterministic Wallets</a>. This is a hierarchical design where a single seed can be used to generate a whole sequence of keys. The entire wallet may then be restored from that seed, rather than requiring the restoring of every single private key.</p>
</blockquote>
<blockquote>
<p>:book: <em><strong>What is a Derivation Path?</strong></em> When you have hierarchical keys, you need to be able to define individual keys as descendents of a seed. For example <code>[0]</code> is the 0th key, <code>[0/1]</code> is the first son of the 0th key, <code>[1/0/1]</code> is the first grandson of the zeroth son of the 1st key. Some keys also contain a <code>'</code> after the number, to show they're hardened, which protects them from a specific attack that can be used to derive an <code>xprv</code> from an <code>xpub</code>. You don't need to worry about the specifics, other than the fact that those <code>'</code>s will cause you formatting troubles when working from the command line.</p>
</blockquote>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> a derivation path defines a key, which means that a key represents a derivation path. They're equivalent. In the case of a descriptor, the derivation path lets <code>bitcoind</code> know where the key that follows in the descriptor came from!</p>
</blockquote>
<p><code>xpubs</code> and <code>xprvs</code> proved insufficient when the types of public keys multiplied under the <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/04_6_Creating_a_Segwit_Transaction.md">SegWit expansion</a>, thus the need for &quot;output descriptors&quot;.</p>
<blockquote>
<p>:book: <em><strong>What is an output descriptor?</strong></em> A precise description of how to derive a Bitcoin address from a combination of a function and one or more inputs to that function.</p>
</blockquote>
<p>The introduction of functions into descriptors is what makes them powerful, because they can be used to transfer all sorts of addresses, from the Legacy addresses that we're working with now to the Segwit and multisig addresses that we'll meet down the road. An individual function matches a particular type of address and correlates with specific rules to generate that address.</p>
<h2 id="capture-a-descriptor"><a class="header" href="#capture-a-descriptor">Capture a Descriptor</a></h2>
<p>Descriptors are visible in several commands such as <code>listunspent</code> and <code>getaddressinfo</code>:</p>
<pre><code>$ bitcoin-cli getaddressinfo ms7ruzvL4atCu77n47dStMb3of6iScS8kZ
{
  &quot;address&quot;: &quot;ms7ruzvL4atCu77n47dStMb3of6iScS8kZ&quot;,
  &quot;scriptPubKey&quot;: &quot;76a9147f437379bcc66c40745edc1891ea6b3830e1975d88ac&quot;,
  &quot;ismine&quot;: true,
  &quot;solvable&quot;: true,
  &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk&quot;,
  &quot;iswatchonly&quot;: false,
  &quot;isscript&quot;: false,
  &quot;iswitness&quot;: false,
  &quot;pubkey&quot;: &quot;03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388&quot;,
  &quot;iscompressed&quot;: true,
  &quot;ischange&quot;: false,
  &quot;timestamp&quot;: 1592335136,
  &quot;hdkeypath&quot;: &quot;m/0'/0'/18'&quot;,
  &quot;hdseedid&quot;: &quot;fdea8e2630f00d29a9d6ff2af7bf5b358d061078&quot;,
  &quot;hdmasterfingerprint&quot;: &quot;d6043800&quot;,
  &quot;labels&quot;: [
    &quot;&quot;
  ]
}
</code></pre>
<p>Here the descriptor is <code>pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk</code>.</p>
<h2 id="understand-a-descriptor"><a class="header" href="#understand-a-descriptor">Understand a Descriptor</a></h2>
<p>A descriptor is broken into several parts:</p>
<pre><code>function([derivation-path]key)#checksum
</code></pre>
<p>Here's what that all means:</p>
<ul>
<li><strong>Function.</strong> The function that is used to create an address from that key. In this cases it's <code>pkh</code>, which is the standard P2PKH legacy address that you met in <a href="03_3_Setting_Up_Your_Wallet.html">§3.3: Setting Up Your Wallet</a>. Similarly, a P2WSH SegWit address would use <code>wsh</code> and a P2WPKH address would use <code>wpkh</code>.</li>
<li><strong>Derivation Path.</strong> This describes what part of an HD wallet is being exported. In this case it's a seed with the fingerprint <code>d6043800</code> and then the 18th child of the 0th child of the 0th child (<code>0'/0'/18'</code>) of that seed. There may also be a further derivation after the key: <code>function([derivation-path]key/more-derivation)#checksum</code>
<ul>
<li>It's worth noting here that if you ever get a derivation path without a fingerprint, you can make it up. It's just that if there's an existing one, you should match it, because if you ever go back to the device that created the fingerprint, you'll need to have the same one.</li>
</ul>
</li>
<li><strong>Key</strong>. The key or keys that are being transferred. This could be something traditional like an <code>xpub</code> or <code>xprv</code>, it could just be a public key for an address as in this case, it could be a set of addresses for a multi-signature, or it could be something else. This is the core data: the function explains what to do with it.</li>
<li><strong>Checksum</strong>. Descriptors are meant to be human transferrable. This checksum makes sure you got it right.</li>
</ul>
<p>See <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md">Bitcoin Core's Info on Descriptor Support</a> for more information.</p>
<h2 id="examine-a-descriptor"><a class="header" href="#examine-a-descriptor">Examine a Descriptor</a></h2>
<p>You can look at a descriptor with the <code>getdescriptorinfo</code> RPC:</p>
<pre><code>$ bitcoin-cli getdescriptorinfo &quot;pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk&quot;
{
  &quot;descriptor&quot;: &quot;pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk&quot;,
  &quot;checksum&quot;: &quot;4ahsl9pk&quot;,
  &quot;isrange&quot;: false,
  &quot;issolvable&quot;: true,
  &quot;hasprivatekeys&quot;: false
}
</code></pre>
<p>Note that it returns a checksum. If you're ever given a descriptor without a checksum, you can learn it with this command:</p>
<pre><code>$ bitcoin-cli getdescriptorinfo &quot;pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)&quot;
{
  &quot;descriptor&quot;: &quot;pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk&quot;,
  &quot;checksum&quot;: &quot;4ahsl9pk&quot;,
  &quot;isrange&quot;: false,
  &quot;issolvable&quot;: true,
  &quot;hasprivatekeys&quot;: false
}
</code></pre>
<p>Besides giving you the checksum, this command also verifies the validity of the descriptor and provides useful information like whether a descriptor contains private keys.</p>
<p>One of the powers of a descriptor is being able to derive an address in a regular way. This is done with the <code>deriveaddresses</code> RPC.</p>
<pre><code>$ bitcoin-cli deriveaddresses &quot;pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk&quot;
[
  &quot;ms7ruzvL4atCu77n47dStMb3of6iScS8kZ&quot;
]
</code></pre>
<p>You'll note it loops back to the address we started with (as it should).</p>
<h2 id="import-a-descriptor"><a class="header" href="#import-a-descriptor">Import a Descriptor</a></h2>
<p>But, the really important thing about a descriptor is that you can take it to another (remote) machine and import it. This is done with the <code>importmulti</code> RPC using the <code>desc</code> option:</p>
<pre><code>remote$ bitcoin-cli importmulti '[{&quot;desc&quot;: &quot;pkh([d6043800/0'&quot;'&quot;'/0'&quot;'&quot;'/18'&quot;'&quot;']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk&quot;, &quot;timestamp&quot;: &quot;now&quot;, &quot;watchonly&quot;: true}]'
[
  {
    &quot;success&quot;: true
  }
]
</code></pre>
<p>First, you'll note our first really ugly use of quotes. Every <code>'</code> in the derivation path had to be replaced with <code>'&quot;'&quot;'</code>. Just expect to have to do that if you're manipulating a descriptor that contains a derivation path. (The other option is to exchange the <code>'</code> with a <code>h</code> for hardened, but that will change you checksum, so if you prefer that for its ease of use, you'll need to get a new checksum with <code>getdescriptorinfo</code>.)</p>
<p>Second, you'll note that we flagged this as <code>watchonly</code>. That's because we know that it's a public key, so we can't spend with it. If we'd failed to enter this flag, <code>importmulti</code> would helpfully have told us something like: <code>Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.</code>.</p>
<blockquote>
<p>:book: <em><strong>What is a watch-only address?</strong></em> A watch-only address allows you to watch for transactions related to an address (or to a whole family of addresses if you used an <code>xpub</code>), but not to spend funds on those addresses.</p>
</blockquote>
<p>Using <code>getaddressesbylabel</code>, we can now see that our address has correctly been imported into our remote machine!</p>
<pre><code>remote$ bitcoin-cli getaddressesbylabel &quot;&quot;
{
  &quot;ms7ruzvL4atCu77n47dStMb3of6iScS8kZ&quot;: {
    &quot;purpose&quot;: &quot;receive&quot;
  }
}
</code></pre>
<h2 id="summary-understanding-the-descriptor"><a class="header" href="#summary-understanding-the-descriptor">Summary: Understanding the Descriptor</a></h2>
<p>Descriptors let you pass public keys and private keys among wallets, but more than that, they allow you to precisely and correctly to define addresses and to derive addresses of a lot of different sorts from a standardized description format.</p>
<blockquote>
<p>:fire: <em><strong>What is the power of descriptors?</strong></em> Descriptors allow you to import and export seeds and keys. That's great if you want to move between different wallets. As a developer, they also allow you to build up the precise sort of addresses that you're interested in creating. For example, we use it in <a href="https://github.com/BlockchainCommons/FullyNoded-2/blob/master/Docs/How-it-works.md">FullyNoded 2</a> to generate a multi-sig from three seeds. </p>
</blockquote>
<p>We'll make real use of descriptors in <a href="07_3_Integrating_with_Hardware_Wallets.html">§7.3</a>, when we're importing addresses from a hardware wallet.</p>
<h2 id="whats-next-9"><a class="header" href="#whats-next-9">What's Next?</a></h2>
<p>Advance through &quot;bitcoin-cli&quot; with <a href="04_0_Sending_Bitcoin_Transactions.html">Chapter Four: Sending Bitcoin Transactions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-four-sending-bitcoin-transactions"><a class="header" href="#chapter-four-sending-bitcoin-transactions">Chapter Four: Sending Bitcoin Transactions</a></h1>
<p>This chapter describes three different methods for sending bitcoins to normal P2PKH addresses from the command line, using only the bitcoin-cli interface.</p>
<h2 id="objectives-for-this-chapter-2"><a class="header" href="#objectives-for-this-chapter-2">Objectives for This Chapter</a></h2>
<p>After working through this chapter, a developer will be able to:</p>
<ul>
<li>Decide How to Send Money Through Bitcoin</li>
<li>Create a Raw Transaction</li>
<li>Use Arithmetic to Calculate Fees</li>
</ul>
<p>Supporting objectives include the ability to:</p>
<ul>
<li>Understand Transactions &amp; Transaction Fees</li>
<li>Understand Legacy &amp; SegWit Transactions</li>
<li>Use Basic Methods to Send Money</li>
<li>Use Auto Fee Calculation Methods to Send Money</li>
<li>Understand the Dangers of Raw Transactions</li>
</ul>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="04_1_Sending_Coins_The_Easy_Way.html">Section One: Sending Coins the Easy Way</a></li>
<li><a href="04_2_Creating_a_Raw_Transaction.html">Section Two: Creating a Raw Transaction</a>
<ul>
<li><a href="04_2__Interlude_Using_JQ.html">Interlude: Using JQ</a></li>
</ul>
</li>
<li><a href="04_3_Creating_a_Raw_Transaction_with_Named_Arguments.html">Section Three: Creating a Raw Transaction with Named Arguments</a></li>
<li><a href="04_4_Sending_Coins_with_a_Raw_Transaction.html">Section Four: Sending Coins with Raw Transactions</a>
<ul>
<li><a href="04_4__Interlude_Using_Curl.html">Interlude: Using Curl</a></li>
</ul>
</li>
<li><a href="04_5_Sending_Coins_with_Automated_Raw_Transactions.html">Section Five: Sending Coins with Automated Raw Transactions</a></li>
<li><a href="04_6_Creating_a_Segwit_Transaction.html">Section Six: Creating a SegWit Transaction</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="41-sending-coins-the-easy-way"><a class="header" href="#41-sending-coins-the-easy-way">4.1: Sending Coins the Easy Way</a></h1>
<p>The <code>bitcoin-cli</code> offers three major ways to send coins: as a simple command; as a raw transaction; and as a raw transaction with calculation. Each has their own advantages and disadvantages. This first method for sending coins is also the simplest.</p>
<h2 id="set-your-transaction-fee"><a class="header" href="#set-your-transaction-fee">Set Your Transaction Fee</a></h2>
<p>Before you send any money on the Bitcoin network, you should think about what transaction fees you're going to pay.</p>
<blockquote>
<p>:book: <em><strong>What is a transaction fee?</strong></em> There's no such thing as a free lunch. Miners incorporate transactions into blocks because they're paid to do so. Not only do they get paid by the network for making the block, but they also get paid by transactors for including their transactions. If you don't pay a fee, your transaction might get stuck ... forever (or, until saved by some of the tricks in <a href="05_0_Controlling_Bitcoin_Transactions.html">Chapter Five</a>).</p>
</blockquote>
<p>When you're using the simple and automated methods for creating transactions, as outlined here and in <a href="04_5_Sending_Coins_with_Automated_Raw_Transactions.html">§4.5: Sending Coins with Automated Raw Transactions</a>, Bitcoin will calculate transaction fees for you. This is done using Floating Fees, where the <code>bitcoind</code> watches how long transactions are taking to confirm and automatically calculates for you what to spend.</p>
<p>You can help control this by putting rational values into your <code>~/.bitcoin/bitcoin.conf</code>. The following low-cost values would ensure that there was a minimum transaction fee of 10,000 satoshis per kByte of data in your transaction and request that the floating fees figure out a good amount to get your transaction somewhere into the next six blocks.</p>
<pre><code>mintxfee=0.0001
txconfirmtarget=6
</code></pre>
<p>However, under the theory that you don't want to wait around while working on a tutorial, we've adopted the following higher values:</p>
<pre><code>mintxfee=0.001
txconfirmtarget=1
</code></pre>
<p>You should enter these into <code>~/.bitcoin/bitcoin.conf</code>, in the main section, toward the top of the file or if you want to be sure you never use it elsewhere, under the <code>[test]</code> section.</p>
<p>In order to get through this tutorial, we're willing to spend 100,000 satoshis per kB on every transaction (about $10!), and we want to get each transaction into the next block! (To put that in perspective, a typical transaction runs between .25 kB and 1 kB, so you'll actually be paying more like $2.50 than $10 ... if this were real money.)</p>
<p>After you've edited your bitcoin.conf file, you'll want to kill and restart bitcoind.</p>
<pre><code>$ bitcoin-cli stop
$ bitcoind -daemon
</code></pre>
<h2 id="get-an-address"><a class="header" href="#get-an-address">Get an Address</a></h2>
<p>You need somewhere to send your coins to. Usually, someone would send you an address, and perhaps give you a signature to prove they own that address. Alternatively, they might give you a QR code to scan, so that you can't make mistakes when typing in the address. In our case, we're going to send coins to <code>n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi</code>, which is a return address for an old Tesetnet faucet.</p>
<blockquote>
<p>:book: <em><strong>What is a QR code?</strong></em> A QR code is just an encoding of a Bitcoin address. Many wallets will generate QR codes for you, while some sites will convert from an address to a QR code. Obviously, you should only accept a QR code from a site that you absolutely trust. A payer can use a bar-code scanner to read in the QR code, then pay to it.</p>
</blockquote>
<h2 id="send-the-coins"><a class="header" href="#send-the-coins">Send the Coins</a></h2>
<p>You're now ready to send some coins. This is actually quite simple via the command line. You just use <code>bitcoin-cli sendtoaddress [address] [amount]</code>. So, to send a little coinage to the address <code>n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi</code> just requires:</p>
<pre><code>$ txid=$(bitcoin-cli sendtoaddress n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi 0.001)
$ echo $txid
93250d0cacb0361b8e21030ac65bc4c2159a53de1075425d800b2d7a8ab13ba8
</code></pre>
<blockquote>
<p>🙏 To help keep testnet faucets alive, try to use the return address of the same faucet you used in the previous chapter on receiving transactions. </p>
</blockquote>
<p>Make sure the address you write in is where you want the money to go. Make <em>double</em> sure. If you make mistakes in Bitcoin, there's no going back.</p>
<p>You'll receive a txid back when you issue this command.</p>
<blockquote>
<p>❕ You may end up with an error code if you don't have enough funds in your wallet to send the transaction. Depending on your current balance <code>bitcoin-cli getbalance</code> you may need to adjust the amount to be sent to account for the amount being sent along with the transaction fee. If your current balance is 0.001, then you could try sending 0.0001. Alternatively, it would be better to instead subtract the expected fee given in the error message from your current balance. This is good practice as many wallets expect you to calculate your own amount + fees when withdrawing, even among popular exchanges. </p>
</blockquote>
<blockquote>
<p>:warning: <strong>WARNING:</strong> The <code>bitcoin-cli</code> command actually generates JSON-RPC commands when it's talking to the bitcoind. They can be really picky. This is an example: if you list the bitcoin amount without the leading zero (i.e. &quot;.1&quot; instead of &quot;0.1&quot;), then bitcoin-cli will fail with a mysterious message.</p>
</blockquote>
<blockquote>
<p>:warning: <strong>WARNING:</strong> Even if you're careful with your inputs, you could see &quot;Fee estimation failed. Fallbackfee is disabled.&quot; Fundamentally, this means that your local <code>bitcoind</code> doesn't have enough information to estimate fees. You should really never see it if you've waited for your blockchain to sync and set up your system with Bitcoin Standup. But if you're not entirely synced, you may see this. It also could be that you're not using a standard <code>bitcoin.conf</code>: the entry <code>blocksonly=1</code> will cause your <code>bitcoind</code> to be unable to estimate fees.</p>
</blockquote>
<h2 id="examine-your-transaction-1"><a class="header" href="#examine-your-transaction-1">Examine Your Transaction</a></h2>
<p>You can look at your transaction using your transaction id:</p>
<pre><code>{
  &quot;amount&quot;: -0.00100000,
  &quot;fee&quot;: -0.00022200,
  &quot;confirmations&quot;: 0,
  &quot;trusted&quot;: true,
  &quot;txid&quot;: &quot;93250d0cacb0361b8e21030ac65bc4c2159a53de1075425d800b2d7a8ab13ba8&quot;,
  &quot;walletconflicts&quot;: [
  ],
  &quot;time&quot;: 1592604194,
  &quot;timereceived&quot;: 1592604194,
  &quot;bip125-replaceable&quot;: &quot;no&quot;,
  &quot;details&quot;: [
    {
      &quot;address&quot;: &quot;n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi&quot;,
      &quot;category&quot;: &quot;send&quot;,
      &quot;amount&quot;: -0.00100000,
      &quot;vout&quot;: 1,
      &quot;fee&quot;: -0.00022200,
      &quot;abandoned&quot;: false
    }
  ],
  &quot;hex&quot;: &quot;0200000001e982921bb0189afc486e20bb05cc5825c71a0ba8868043ed04ece9ab0cb12a8e010000006a47304402200fc493a01c5c9d9574f7c321cee6880f7f1df847be71039e2d996f7f75c17b3d02203057f5baa48745ba7ab5f1d4eed11585bd8beab838b1ca03a4138516fe52b3b8012102fd5740996d853ea51a6904cf03257fc11204b0179f344c49739ec5b20b39c9bafeffffff02e8640d0000000000160014d37b6ae4a917bcc873f6395741155f565e2dc7c4a0860100000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac780b1b00&quot;
}
</code></pre>
<p>You can see not only the amount transferred (.001 BTC) but also a transaction fee (.000222 BTC), which is about a quarter of the .001 BTC/kB minimum fee that was set, which suggests that the transaction was about a quarter of a kB in size.</p>
<p>While you are waiting for this transaction to clear, you'll note that <code>bitcoin-cli getbalance</code> shows that all of your money is gone (or, at least, all of your money from a single incoming transaction). Similarly, <code>bitcoin-cli listunspent</code> will show that an entire transaction is gone, even if it was more than what you wanted to send. There's a reason for this: whenever you get money in, you have to send it <em>all</em> out together, and you have to perform some gymnastics if you actually want to keep some of it! Once again, <code>sendtoaddress</code> takes care of this all for you, which means you don't have to worry about making change until you send a raw transaction. In this case, a new transaction will appear with your change when your spend is incorporated into a block.</p>
<h2 id="summary-sending-coins-the-easy-way"><a class="header" href="#summary-sending-coins-the-easy-way">Summary: Sending Coins the Easy Way</a></h2>
<p>To send coins the easy way, make sure your transaction defaults are rationale, get an address, and send coins there. That's why they call it easy!</p>
<blockquote>
<p>:fire: <em><strong>What is the power of sending coins the easy way?</strong></em></p>
</blockquote>
<blockquote>
<p><em>The advantages.</em> It's easy. You don't have to worry about arcane things like UTXOs. You don't have to calculate transaction fees by hand, so you're not likely to make mistakes that cost you large amounts of money. If your sole goal is to sit down at your computer and send some money, this is the way to go.</p>
</blockquote>
<blockquote>
<p><em>The disadvantages.</em> It's high level. You have very little control over what's happening, and you can't do anything fancy. If you're planning to write more complex Bitcoin software or want a deeper understanding of how Bitcoin works, then the easy way is just a dull diversion before you get to the real stuff.</p>
</blockquote>
<h2 id="whats-next-10"><a class="header" href="#whats-next-10">What's Next?</a></h2>
<p>Continue &quot;Sending Bitcoin Transactions&quot; with <a href="04_2_Creating_a_Raw_Transaction.html">§4.2 Creating a Raw Transaction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-using-jq"><a class="header" href="#interlude-using-jq">Interlude: Using JQ</a></h1>
<p>Creating a raw transaction revealed how more complex bitcoin-cli results can't easily be saved into command-line variables. The answer is JQ, which allows you to filter out individual elements from more complex JSON data.</p>
<h2 id="install-jq"><a class="header" href="#install-jq">Install JQ</a></h2>
<p>JQ is available from a <a href="https://stedolan.github.io/jq/">Github repository</a>. Just download for Linux, OS X, or Windows, as appropriate.</p>
<p>Once you've downloaded the binary, you can install it on your system. If you're working on a Debian VPS as we suggest, your installation will look like this:</p>
<pre><code>$ mv jq-linux64 jq
$ sudo /usr/bin/install -m 0755 -o root -g root -t /usr/local/bin jq
</code></pre>
<blockquote>
<p>:book: <em><strong>What is JQ?</strong></em> The repository explains it best, saying &quot;jq is like sed for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that sed, awk, grep and friends let you play with text.&quot;</p>
</blockquote>
<h2 id="use-jq-to-access-a-json-object-value-by-key"><a class="header" href="#use-jq-to-access-a-json-object-value-by-key">Use JQ to Access a JSON Object Value by Key</a></h2>
<p><strong>Usage Example:</strong> <em>Capture the hex from a signed raw transaction.</em></p>
<p>In the previous section, the use of <code>signrawtransaction</code> offered an example of not being able to easily capture data into variables due to the use of JSON output:</p>
<pre><code>$ bitcoin-cli signrawtransactionwithwallet $rawtxhex
{
  &quot;hex&quot;: &quot;02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000&quot;,
  &quot;complete&quot;: true
}
</code></pre>
<p>Fortunately, JQ can easily capture data of that sort!</p>
<p>To use JQ, run <code>jq</code> at the backend of a pipe, and always use the standard invocation of <code>jq -r '.'</code>. The <code>-r</code> tells JQ to produce raw output, which will work for command-line variables, while the <code>.</code> tells jq to output. We protect that argument in <code>' '</code> because we'll need that protection later as our <code>jq</code> invocations get more complex.</p>
<p>To capture a specific value from a JSON object, you just list the key after the <code>.</code>:</p>
<pre><code>$ bitcoin-cli signrawtransactionwithwallet $rawtxhex | jq -r '.hex'
02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000
</code></pre>
<p>With that tool in hand, you can capture information from JSON objects to command-line variables:</p>
<pre><code>$ signedtx=$(bitcoin-cli signrawtransactionwithwallet $rawtxhex | jq -r '.hex')
$ echo $signedtx
02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000
</code></pre>
<p>You can then use those variables easily and without error:</p>
<pre><code>$ bitcoin-cli sendrawtransaction $signedtx
3f9ccb6e16663e66dc119de1866610cc4f7a83079bfec2abf0598ed3adf10a78
</code></pre>
<h2 id="use-jq-to-access-single-json-object-values-in-an-array-by-key"><a class="header" href="#use-jq-to-access-single-json-object-values-in-an-array-by-key">Use JQ to Access Single JSON Object Values in an Array by Key</a></h2>
<p><strong>Usage Example:</strong> <em>Capture the txid and vout for a selected UTXO.</em></p>
<p>Grabbing data out of a JSON object is easy, but what if that JSON object is in a JSON array? The <code>listunspent</code> command offers a great example, because it'll usually contain a number of different transactions. What if you want to capture specific information from <em>one</em> of them?</p>
<p>When working with a JSON array, the first thing you need to do is tell JQ which index to access. For example, you might have looked through your transactions in <code>listunspent</code> and decided that you wanted to work with the second of them. You use <code>'.[1]'</code> to access that second element. The <code>[]</code> says that we're referencing a JSON array and the <code>1</code> says we want the 1st index.</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[1]'
{
  &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
  &quot;vout&quot;: 0,
  &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
  &quot;label&quot;: &quot;&quot;,
  &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
  &quot;amount&quot;: 0.00022,
  &quot;confirmations&quot;: 9,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true,
  &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
  &quot;safe&quot;: true
}
</code></pre>
<p>You can then capture an individual value from that selected array by (1) using a pipe <em>within</em> the JQ arguments; and then (2) requesting the specific value afterward, as in the previous example. The following would capture the <code>txid</code> from the 1st JSON object in the JSON array produced by <code>listunspent</code>:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[1] | .txid'
91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c
</code></pre>
<p>Carefully note how the <code>' 's</code> go around the whole JQ expression <em>including</em> the pipe.</p>
<p>This method can be used to fill in variables for a UTXO that you want to use:</p>
<pre><code>$ newtxid=$(bitcoin-cli listunspent | jq -r '.[1] | .txid')
$ newvout=$(bitcoin-cli listunspent | jq -r '.[1] | .vout')
$ echo $newtxid
91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c
$ echo $newvout
0
</code></pre>
<p>Voila! We could now create a new raw transaction using our 1st UTXO as an input, without having to type in any of the UTXO info by hand!</p>
<h2 id="use-jq-to-access-matching-json-object-values-in-an-array-by-key"><a class="header" href="#use-jq-to-access-matching-json-object-values-in-an-array-by-key">Use JQ to Access Matching JSON Object Values in an Array by Key</a></h2>
<p><strong>Usage Example:</strong> <em>List the value of all unspent UTXOs.</em></p>
<p>Instead of accessing a single, specific value in a specific JSON object, you could instead access all of a specific value across all the JSON objects. This is done with <code>.[]</code>, where no index is specified. For example, this would list all unspent funds:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[] | .amount'
0.0001
0.00022
</code></pre>
<h2 id="use-jq-for-simple-calculations-by-key"><a class="header" href="#use-jq-for-simple-calculations-by-key">Use JQ for Simple Calculations by Key</a></h2>
<p><strong>Usage Example:</strong> <em>Sum the value of all unspent UTXOs.</em></p>
<p>At this point, you can start using JQ output for simple math. For example, adding up the values of those unspent transactions with a simple <code>awk</code> script would give you the equivalent of <code>getbalance</code>:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[] | .amount' | awk '{s+=$1} END {print s}'
0.00032
$ bitcoin-cli getbalance
0.00032000
</code></pre>
<h2 id="use-jq-to-display-multiple-json-object-values-in-an-array-by-multiple-keys"><a class="header" href="#use-jq-to-display-multiple-json-object-values-in-an-array-by-multiple-keys">Use JQ to Display Multiple JSON Object Values in an Array by Multiple Keys</a></h2>
<p><strong>Usage Example:</strong> <em>List usage information for all UTXOs.</em></p>
<p>JQ can easily capture individual elements from JSON objects and arrays and place those elements into variables. That will be its prime use in future sections. However, it can also be used to cut down huge amounts of information output by <code>bitcoin-cli</code> into reasonable amounts of information.</p>
<p>For example, you might want to see a listing of all your UTXOs (<code>.[]</code>) and get a listing of all of their most important information (<code>.txid, .vout, .amount</code>):</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[] | .txid, .vout, .amount'
ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36
0
0.0001
91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c
0
0.00022
</code></pre>
<p>This makes it easy to decide which UTXOs to spend in a raw transaction, but it's not very pretty.</p>
<p>Fortunately, JQ also lets you be fancy. You can use <code>{}</code>s to create new JSON objects (either for additional parsing or for pretty output). You also get to define the name of the new key for each of your values. The resulting output should be much more intuitive and less prone to error (though obviously, less useful for dumping info straight into variables).</p>
<p>The following example shows the exact same parsing of <code>listunspent</code>, but with the each old JSON object rebuilt as a new, abridged JSON object, with all of the new values named with their old keys:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[] | { txid: .txid, vout: .vout, amount: .amount }'
{
  &quot;txid&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
  &quot;vout&quot;: 0,
  &quot;amount&quot;: 0.0001
}
{
  &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
  &quot;vout&quot;: 0,
  &quot;amount&quot;: 0.00022
}
</code></pre>
<p>You could of course rename your new keys as you see fit. There's nothing magic in the original names:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[] | { tx: .txid, output: .vout, bitcoins: .amount }'
{
  &quot;tx&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
  &quot;output&quot;: 0,
  &quot;bitcoins&quot;: 0.0001
}
{
  &quot;tx&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
  &quot;output&quot;: 0,
  &quot;bitcoins&quot;: 0.00022
}
</code></pre>
<h2 id="use-jq-to-access-json-objects-by-looked-up-value"><a class="header" href="#use-jq-to-access-json-objects-by-looked-up-value">Use JQ to Access JSON Objects by Looked-Up Value</a></h2>
<p><strong>Usage Example:</strong> <em>Automatically look up UTXOs being used in a transaction.</em></p>
<p>The JQ lookups so far have been fairly simple: you use a key to look up one or more values in a JSON object or array. But what if you instead want to look up a value in a JSON object ... by another value? This sort of indirect lookup has real applicability when you're working with transactions built on existing UTXOs. For example, it can allow you to calculate the sum value of the UTXOs being used in a transaction, something that is vitally important.</p>
<p>This example uses the following raw transaction. Note that this is a more complex raw transaction with two inputs and two outputs. We'll learn about making those in a few sections; for now, it's necessary to be able to offer robust examples. Note that unlike our previous examples, this one has two objects in its <code>vin</code> array and two in its <code>vout</code> array.</p>
<pre><code>$ bitcoin-cli decoderawtransaction $rawtxhex
{
  &quot;txid&quot;: &quot;6f83a0b78c598de01915554688592da1d7a3047eacacc8a9be39f5396bf0a07e&quot;,
  &quot;hash&quot;: &quot;6f83a0b78c598de01915554688592da1d7a3047eacacc8a9be39f5396bf0a07e&quot;,
  &quot;size&quot;: 160,
  &quot;vsize&quot;: 160,
  &quot;version&quot;: 2,
  &quot;locktime&quot;: 0,
  &quot;vin&quot;: [
    {
      &quot;txid&quot;: &quot;d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c&quot;,
      &quot;vout&quot;: 1,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;&quot;,
        &quot;hex&quot;: &quot;&quot;
      },
      &quot;sequence&quot;: 4294967295
    },
    {
      &quot;txid&quot;: &quot;c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b&quot;,
      &quot;vout&quot;: 1,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;&quot;,
        &quot;hex&quot;: &quot;&quot;
      },
      &quot;sequence&quot;: 4294967295
    }
  ],
  &quot;vout&quot;: [
    {
      &quot;value&quot;: 1.00000000,
      &quot;n&quot;: 0,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_DUP OP_HASH160 cfc39be7ea3337c450a0c77a839ad0e160739058 OP_EQUALVERIFY OP_CHECKSIG&quot;,
        &quot;hex&quot;: &quot;76a914cfc39be7ea3337c450a0c77a839ad0e16073905888ac&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;pubkeyhash&quot;,
        &quot;addresses&quot;: [
          &quot;mzTWVv2QSgBNqXx7RC56zEhaQPve8C8VS9&quot;
        ]
      }
    },
    {
      &quot;value&quot;: 0.04500000,
      &quot;n&quot;: 1,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_DUP OP_HASH160 166692bda9f25ced145267bb44286e8ee3963d26 OP_EQUALVERIFY OP_CHECKSIG&quot;,
        &quot;hex&quot;: &quot;76a914166692bda9f25ced145267bb44286e8ee3963d2688ac&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;pubkeyhash&quot;,
        &quot;addresses&quot;: [
          &quot;mhZQ3Bih6wi7jP1tpFZrCcyr4NsfCapiZP&quot;
        ]
      }
    }
  ]
}
</code></pre>
<h3 id="retrieve-the-values"><a class="header" href="#retrieve-the-values">Retrieve the Value(s)</a></h3>
<p>Assume that we know exactly how this transaction is constructed: we know that it uses two UTXOs as input. To retrieve the txid for the two UTXOs, we could use <code>jq</code> to look up the transaction's .vin value, then reference the .vin's 0th array, then that array's .txid value. Afterward, we could do the same with the 1st array, then the same with the .vin's two .vout values. Easy:</p>
<pre><code>$ usedtxid1=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[0] | .txid')
$ echo $usedtxid1
d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c
$ usedtxid2=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[1] | .txid')
$ echo $usedtxid2
c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b

$ usedvout1=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[0] | .vout')
$ echo $usedvout1
1
$ usedvout2=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[1] | .vout')
$ echo $usedvout2
1
</code></pre>
<p>However, it would be better to have a general case that <em>automatically</em> saved all the txids of our UTXOs.</p>
<p>We already know that we can access all of the <code>.txid</code>s by using an <code>.[]</code> array value. We can use that to build a general .txid lookup:</p>
<pre><code>$ usedtxid=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[] | .txid'))
$ echo ${usedtxid[0]}
d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c
$ echo ${usedtxid[1]}
c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b

$ usedvout=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[] | .vout'))
$ echo ${usedvout[0]}
1
$ echo ${usedvout[1]}
1
</code></pre>
<p>The only real trick here is how we saved the information using the bash shell. Rather than saving to a variable with <code>$(command)</code>, we instead saved to an array with <code>($(command))</code>. We were then able to access the individual bash array elements with a <code>${variable[n]}</code> construction. We could instead access the whole array with <code>${variable[@]}</code>. (Yeah, no one ever said bash was pretty.)</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> Always remember that a UTXO is a transaction <em>plus</em> a vout. We missed the vout the first time we wrote this JQ example, and it stopped working when we ended up with a situation where we'd been sent two <code>vouts</code> from the same transaction.</p>
</blockquote>
<h3 id="retrieve-the-related-objects"><a class="header" href="#retrieve-the-related-objects">Retrieve the Related Object(s)</a></h3>
<p>You can now use your saved <code>txid</code> and <code>vout</code> information to reference UTXOs in <code>listunspent</code>. To find the information on the UTXOs being used by the raw transaction, you need to look through the entire JSON array (<code>[]</code>) of unspent transactions. You can then choose (<code>select</code>) individual JSON objects that include (<code>contains</code>) the txids. You <em>then</em> select (<code>select</code>) the transactions among those that <em>also</em> contains (<code>contain</code>) the correct vout.</p>
<p>The use of another level of pipe is the standard methodology of JQ: you grab a set of data, then you whittle it down to all the relevant transactions, then you whittle it down to the vouts that were actually used from those transactions. However, the <code>select</code> and <code>contains</code> arguments are something new. They show off some of the complexity of JSON that goes beyond the scope of this tutorial; for now just know that this particular invocation will work to grab matching objects.</p>
<p>To start simply, this picks out the two UTXOs one at a time:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r '.[] | select (.txid | contains(&quot;'${usedtxid[0]}'&quot;)) | select(.vout | contains('${usedvout[0]}'))'
{
  &quot;txid&quot;: &quot;d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;miSrC3FvkPPZgqqvCiQycq7io7wTSVsAFH&quot;,
  &quot;scriptPubKey&quot;: &quot;76a91420219e4f3c6bc0f6524d538009e980091b3613e888ac&quot;,
  &quot;amount&quot;: 0.9,
  &quot;confirmations&quot;: 6,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}
$ bitcoin-cli listunspent | jq -r '.[] | select (.txid | contains(&quot;'${usedtxid[1]}'&quot;)) | select(.vout | contains('${usedvout[1]}'))'
{
  &quot;txid&quot;: &quot;c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;mzizSuAy8aL1ytFijds7pm4MuDPx5aYH5Q&quot;,
  &quot;scriptPubKey&quot;: &quot;76a914d2b12da30320e81f2dfa416c5d9499d08f778f9888ac&quot;,
  &quot;amount&quot;: 0.4,
  &quot;confirmations&quot;: 5,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}
</code></pre>
<p>A simple bash for-loop could instead give you <em>all</em> of your UTXOs:</p>
<pre><code>$ for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r '.[] | select (.txid | contains(&quot;'${txid}'&quot;)) | select(.vout | contains('$vout'))'; done;
{
  &quot;txid&quot;: &quot;d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;miSrC3FvkPPZgqqvCiQycq7io7wTSVsAFH&quot;,
  &quot;scriptPubKey&quot;: &quot;76a91420219e4f3c6bc0f6524d538009e980091b3613e888ac&quot;,
  &quot;amount&quot;: 0.9,
  &quot;confirmations&quot;: 7,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}
{
  &quot;txid&quot;: &quot;c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;mzizSuAy8aL1ytFijds7pm4MuDPx5aYH5Q&quot;,
  &quot;scriptPubKey&quot;: &quot;76a914d2b12da30320e81f2dfa416c5d9499d08f778f9888ac&quot;,
  &quot;amount&quot;: 0.4,
  &quot;confirmations&quot;: 6,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}

</code></pre>
<p>Note that we used yet another bit of array ugliness <code>${#usedtxid[*]}</code> to determine the size of the array, then accessed each value in the <code>usedtxid</code> array and each value in the parallel <code>usedvout</code> array, putting them into simpler variables for less-ugly access.</p>
<h2 id="use-json-for-simple-calculation-by-value"><a class="header" href="#use-json-for-simple-calculation-by-value">Use JSON for Simple Calculation by Value</a></h2>
<p><strong>Usage Example:</strong> <em>Automatically calculate the value of the UTXOs used in a transaction.</em></p>
<p>You can now go one step further, and request the .amount (or any other JSON key-value) from the UTXOs you're retrieving.</p>
<p>This example repeats the usage the <code>$usedtxid</code> and <code>$usedvout</code> arrays that were set as follows:</p>
<pre><code>$ usedtxid=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[] | .txid'))
$ usedvout=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[] | .vout'))
</code></pre>
<p>The same <code>for</code> script can be used to step through those arrays, but with an added pipe in the JQ that outputs the <code>amount</code> value for each of the UTXOs selected.</p>
<pre><code>$ for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r '.[] | select (.txid | contains(&quot;'${txid}'&quot;)) | select(.vout | contains('$vout')) | .amount'; done;
0.9
0.4
</code></pre>
<p>At this point, you can also sum up the .amounts with an <code>awk</code> script, to really see how much money is in the UTXOs that the transaction is spending:</p>
<pre><code>$ for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r '.[] | select (.txid | contains(&quot;'${txid}'&quot;)) | select(.vout | contains('$vout')) | .amount'; done | awk '{s+=$1} END {print s}'
1.3
</code></pre>
<p>Whew!</p>
<h2 id="use-jq-for-complex-calculations"><a class="header" href="#use-jq-for-complex-calculations">Use JQ for Complex Calculations</a></h2>
<p><strong>Usage Example:</strong> <em>Calculate the fee for a transaction.</em></p>
<p>Figuring out the complete transaction fee at this point just requires one more bit of math: determining how much money is going through the .vout. That's a simple use of JQ where you just use <code>awk</code> to sum up the <code>value</code> of all the <code>vout</code> information:</p>
<pre><code>$ bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vout  [] | .value' | awk '{s+=$1} END {print s}'
1.045
</code></pre>
<p>To complete the transaction fee calculation, you subtract the .vout .amount (1.045) from the .vin .amount (1.3).</p>
<p>To do this, you'll need to install <code>bc</code>:</p>
<pre><code>$ sudo apt-get install bc
</code></pre>
<p>Putting it all together creates a complete calculator in just five lines of script:</p>
<pre><code>$ usedtxid=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[] | .txid'))
$ usedvout=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vin | .[] | .vout'))
$ btcin=$(for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r '.[] | select (.txid | contains(&quot;'${txid}'&quot;)) | select(.vout | contains('$vout')) | .amount'; done | awk '{s+=$1} END {print s}')
$ btcout=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r '.vout  [] | .value' | awk '{s+=$1} END {print s}')
$ echo &quot;$btcin-$btcout&quot;| /usr/bin/bc
.255
</code></pre>
<p>And that's also a good example of why you double-check your fees: we'd intended to send a transaction fee of 5,000 satoshis, but sent 255,000 satoshis instead. Whoops!</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> The first time we wrote up this lesson, we genuinely miscalculated our fee and didn't see it until we ran our fee calculator. It's <em>that</em> easy, then your money is gone. (The example above is actually from our second iteration of the calculator, and that time we made the mistake on purpose.)</p>
</blockquote>
<p>For more JSON magic (and if any of this isn't clear), please read the <a href="https://stedolan.github.io/jq/manual/">JSON Manual</a> and the <a href="https://github.com/stedolan/jq/wiki/Cookbook">JSON Cookbook</a>. We'll be regularly using JQ in future examples.</p>
<h2 id="make-some-new-aliases"><a class="header" href="#make-some-new-aliases">Make Some New Aliases</a></h2>
<p>JQ code can be a little unwieldy, so you should consider adding some longer and more interesting invocations to your ~/.bash_profile. </p>
<p>Any time you're looking through a large mass of information in a JSON object output by a <code>bitcoin-cli</code> command, consider writing an alias to strip it down to just what you want to see.</p>
<pre><code>alias btcunspent=&quot;bitcoin-cli listunspent | jq -r '.[] | { txid: .txid, vout: .vout, amount: .amount }'&quot;
</code></pre>
<h2 id="run-the-transaction-fee-script"><a class="header" href="#run-the-transaction-fee-script">Run The Transaction Fee Script</a></h2>
<p>The <a href="src/04_2_i_txfee-calc.sh">Fee Calculation Script</a> is available in src-code directory. You can download it and save it as <code>txfee-calc.sh</code>.</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> This script has not been robustly checked. If you are going to use it to verify real transaction fees you should only do it as a triple-check after you've already done all the math yourself.</p>
</blockquote>
<p>Be sure the permissions on the script are right:</p>
<pre><code>$ chmod 755 txfee-calc.sh
</code></pre>
<p>You can then run the script as follows:</p>
<pre><code>$ ./txfee-calc.sh $rawtxhex
.255
</code></pre>
<p>You may also want to create an alias:</p>
<pre><code>alias btctxfee=&quot;~/txfee-calc.sh&quot;
</code></pre>
<h2 id="summary-using-jq"><a class="header" href="#summary-using-jq">Summary: Using JQ</a></h2>
<p>JQ makes it easy to extract information from JSON arrays and objects. It can also be used in shell scripts for fairly complex calculations that will make your life easier.</p>
<h2 id="whats-next-11"><a class="header" href="#whats-next-11">What's Next?</a></h2>
<p>Continue &quot;Sending Bitcoin Transactions&quot; with <a href="04_3_Creating_a_Raw_Transaction_with_Named_Arguments.html">§4.3 Creating a Raw Transaction with Named Arguments</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="42-creating-a-raw-transaction"><a class="header" href="#42-creating-a-raw-transaction">4.2 Creating a Raw Transaction</a></h1>
<p>You're now ready to create Bitcoin raw transactions. This allows you to send money but to craft the transactions as precisely as you want. This first section focuses on a simple one-input, one-output transaction. This sort of transaction <em>isn't</em> actually that useful, because you're rarely going to want to send all of your money to one person (unless you're actually just forwarding it on, such as if you're moving things from one wallet to another). Thus, we don't label this section as a way to send money. It's just a foundational stepping stone to <em>actually</em> sending money with a raw transaction.</p>
<h2 id="understand-the-bitcoin-transaction"><a class="header" href="#understand-the-bitcoin-transaction">Understand the Bitcoin Transaction</a></h2>
<p>Before you dive into actually creating raw transactions, you should make sure you understand how a Bitcoin transaction works. It's all about the UTXOs.</p>
<blockquote>
<p>:book: <em><strong>What is a UTXO?</strong></em> When you receive cash in your Bitcoin wallet, it appears as an individual transaction. Each of these transactions is called a Unspent Transaction Output (UTXO). It doesn't matter if various payments were made to the same address or to multiple addresses: each incoming transaction remains distinct in your wallet as a UTXO.</p>
</blockquote>
<p>When you create a new outgoing transaction, you gather together one or more UTXOs, each of which represents a blob of money that you received. You use these as inputs for a new transaction. Together their amount must equal what you want to spend <em>or more</em>. Then, you generate one or more outputs, which give the money represented by the inputs to one or more people. This creates new UTXOs for the recipients, which may then use <em>those</em> to fund future transactions.</p>
<p>Here's the trick: <em>all of the UTXOs that you gather are spent in full!</em> That means that if you want to send just part of the money in a UTXO to someone else, then you also have to generate an additional output that sends the rest back to you! For now, we won't worry about that, but the use of a change address will be vital when moving on from the theory of this chapter to more practical transactions.</p>
<h2 id="list-your-unspent-transactions"><a class="header" href="#list-your-unspent-transactions">List Your Unspent Transactions</a></h2>
<p>In order to create a new raw transaction, you must know what UTXOs you have on-hand to spend. You can determine this information with the <code>bitcoin-cli listunspent</code> command:</p>
<pre><code>$ bitcoin-cli listunspent
[
  {
    &quot;txid&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9141b72503639a13f190bf79acf6d76255d772360b788ac&quot;,
    &quot;amount&quot;: 0.00010000,
    &quot;confirmations&quot;: 20,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/1']02fd5740996d853ea51a6904cf03257fc11204b0179f344c49739ec5b20b39c9ba)#62rud39c&quot;,
    &quot;safe&quot;: true
  },
  {
    &quot;txid&quot;: &quot;61f3b7016bf1ecc3987b8805207e79362e4de8026682e149107999b779426e3a&quot;,
    &quot;vout&quot;: 1,
    &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
    &quot;amount&quot;: 0.00050000,
    &quot;confirmations&quot;: 3,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
    &quot;safe&quot;: true
  },
  {
    &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
    &quot;amount&quot;: 0.00022000,
    &quot;confirmations&quot;: 3,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
    &quot;safe&quot;: true
  }
]

</code></pre>
<p>This listing shows three different UTXOs, worth .0001, .0005 and .00022 BTC. Note that each has its own distinct txid and remains distinct in the wallet, even the last two, which were sent to the same address.</p>
<p>When you want to spend a UTXO, it's not sufficient to just know the transaction id. That's because each transaction can have multiple outputs! Remember that first chunk of money that the faucet sent us? In the transaction, some money went to us and some went to someone else. The <code>txid</code> refers to the overall transaction, while a <code>vout</code> says which of multiple outputs you've received. In this list, each of these transactions is the 0th <code>vout</code> of a previous transaction, but <em>that doesn't have to be the case</em>.</p>
<p>So, txid+vout=UTXO. This will be the foundation of any raw transaction.</p>
<h2 id="write-a-raw-transaction-with-one-output"><a class="header" href="#write-a-raw-transaction-with-one-output">Write a Raw Transaction with One Output</a></h2>
<p>You're now ready to write a simple, example raw transaction that shows how to send the entirety of a UTXO to another party. As noted, this is not necessarily a very realistic real-world case.</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> It is very easy to lose money with a raw transaction. Consider all instructions on sending bitcoins via raw transactions to be <em>very</em>, <em>very</em> dangerous. Whenever you're actually sending real money to other people, you should instead use one of the other methods explained in this chapter. Creating raw transactions is extremely useful if you're writing bitcoin programs, but <em>only</em> when you're writing bitcoin programs. (For example: in writing this example for one version of this tutorial, we accidentally spent the wrong transaction, even though it had about 10x as much value. Almost all of that was lost to the miners.)</p>
</blockquote>
<h3 id="prepare-the-raw-transaction"><a class="header" href="#prepare-the-raw-transaction">Prepare the Raw Transaction</a></h3>
<p>For best practices, we'll start out each transaction by carefully recording the txids and vouts that we'll be spending.</p>
<p>In this case, we're going to spend the one worth .00050000 BTC because it's the only one with a decent value.</p>
<pre><code>$ utxo_txid=&quot;61f3b7016bf1ecc3987b8805207e79362e4de8026682e149107999b779426e3a&quot;
$ utxo_vout=&quot;1&quot;
</code></pre>
<p>You should similarly record your recipient address, to make sure you have it right. We're again sending some money back to the TP faucet:</p>
<pre><code>$ recipient=&quot;n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi&quot;
</code></pre>
<p>As always, check your variables carefully, to make sure they're what you expect!</p>
<pre><code>$ echo $utxo_txid
61f3b7016bf1ecc3987b8805207e79362e4de8026682e149107999b779426e3a
$ echo $utxo_vout
1
$ echo $recipient
n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi
</code></pre>
<p>That recipient is particularly important, because if you mess it up, your money is <em>gone</em>! (And as we already saw, choosing the wrong transaction can result in lost money!) So triple check it all.</p>
<h3 id="understand-the-transaction-fee"><a class="header" href="#understand-the-transaction-fee">Understand the Transaction Fee</a></h3>
<p>Each transaction has a fee associated with. It's <em>implicit</em> when you send a raw transaction: the amount that you will pay as a fee is always equal to the amount of your input minus the amount of your output. So, you have to decrease your output a little bit from your input to make sure that your transaction goes out.</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> This is the very dangerous part of raw transactions!! Because you automatically expend all of the amount in the UTXOs that you use, it's critically important to make sure that you know: (1) precisely what UTXOs you're using; (2) exactly how much money they contain; (3) exactly how much money you're sending out; and (4) what the difference is. If you mess up and you use the wrong UTXO (with more money than you thought) or if you send out too little money, the excess is lost. Forever. Don't make that mistake! Know your inputs and outputs <em>precisely</em>. Or better, don't use raw transactions except as part of a carefully considered and triple-checked program.</p>
</blockquote>
<blockquote>
<p>:book: <em><strong>How much should you spend on transaction fees?</strong></em> <a href="https://bitcoinfees.21.co/">Bitcoin Fees</a> has a nice live assessment. It says that the &quot;fastest and cheapest transaction fee is currently 42 satoshis/byte&quot; and that &quot;For the median transaction size of 224 bytes, this results in a fee of 9,408 satoshis&quot;.</p>
</blockquote>
<p>Currently Bitcoin Fees suggests a transaction fee of about 10,000 satoshis, which is the same as .0001 BTC. Yes, that's for the mainnet, not the testnet, but we want to test out things realistically, so that's what we're going to use.</p>
<p>In this case, that means taking the .0005 BTC in the UTXO we're selected, reducing it by .0001 BTC for the transaction fee, and sending the remaining .0004 BTC. (And this is an example of why micropayments don't work on the Bitcoin network, because a $1 or so transaction fee is pretty expensive when you're sending $4, let alone if you were trying to make a micropayment of $0.50. But that's always why we have Lightning.)</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> The lower that you set your transaction fee, the longer before your transaction is built into a block. The Bitcoin Fees site lists expected times, from an expected 0 blocks, to 22. Since blocks are built on average every 10 minutes, that's the difference between a few minutes and a few hours! So, choose a transaction fee that's appropriate for what you're sending. Note that you should never drop below the minimum relay fee, which is .0001 BTC.</p>
</blockquote>
<h3 id="write-the-raw-transaction"><a class="header" href="#write-the-raw-transaction">Write the Raw Transaction</a></h3>
<p>You're now ready to create the raw transaction. This uses the <code>createrawtransaction</code> command, which might look a little intimidating. That's because the <code>createrawtransaction</code> command doesn't entirely shield you from the JSON RPC that the bitcoin-cli uses. Instead, you are going to input a JSON array to list the UTXOs that you're spending and a JSON object to list the outputs.</p>
<p>Here's the standard format:</p>
<pre><code>$ bitcoin-cli createrawtransaction
'''[
     {
       &quot;txid&quot;: &quot;'$your_txid'&quot;,
       &quot;vout&quot;: '$your_vout'
      }
]'''
'''{
   &quot;'$your_recipient'&quot;: bitcoin_amount
 }'''
</code></pre>
<p>Yeah, there are all kinds of crazy quotes there, but trust that they'll do the right thing. Use <code>'''</code> to mark the start and end of the JSON array and the JSON object. Protect normal words like <code>&quot;this&quot;</code>, but you don't need to protect normal numbers: <code>0</code>. If they're variables, insert single quotes, like <code>&quot;'$this_word'&quot;</code> and <code>'$this_num'</code>. (Whew. You'll get used to it.)</p>
<p>Here's a command that creates a raw transaction to send your $utxo to your $recipient</p>
<pre><code>$ rawtxhex=$(bitcoin-cli createrawtransaction '''[ { &quot;txid&quot;: &quot;'$utxo_txid'&quot;, &quot;vout&quot;: '$utxo_vout' } ]''' '''{ &quot;'$recipient'&quot;: 0.0004 }''')
$ echo $rawtxhex
02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f3610100000000ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000
</code></pre>
<h3 id="verify-your-raw-transaction"><a class="header" href="#verify-your-raw-transaction">Verify Your Raw Transaction</a></h3>
<p>You should next verify your rawtransaction with <code>decoderawtransaction</code> to make sure that it will do the right thing.</p>
<pre><code>$ bitcoin-cli decoderawtransaction $rawtxhex
{
  &quot;txid&quot;: &quot;dcd2d8f0ec5581b806a1fbe00325e1680c4da67033761b478a26895380cc1298&quot;,
  &quot;hash&quot;: &quot;dcd2d8f0ec5581b806a1fbe00325e1680c4da67033761b478a26895380cc1298&quot;,
  &quot;version&quot;: 2,
  &quot;size&quot;: 85,
  &quot;vsize&quot;: 85,
  &quot;weight&quot;: 340,
  &quot;locktime&quot;: 0,
  &quot;vin&quot;: [
    {
      &quot;txid&quot;: &quot;61f3b7016bf1ecc3987b8805207e79362e4de8026682e149107999b779426e3a&quot;,
      &quot;vout&quot;: 1,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;&quot;,
        &quot;hex&quot;: &quot;&quot;
      },
      &quot;sequence&quot;: 4294967295
    }
  ],
  &quot;vout&quot;: [
    {
      &quot;value&quot;: 0.00040000,
      &quot;n&quot;: 0,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_DUP OP_HASH160 e7c1345fc8f87c68170b3aa798a956c2fe6a9eff OP_EQUALVERIFY OP_CHECKSIG&quot;,
        &quot;hex&quot;: &quot;76a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;pubkeyhash&quot;,
        &quot;addresses&quot;: [
          &quot;n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi&quot;
        ]
      }
    }
  ]
}
</code></pre>
<p>Check the <code>vin</code>. Are you spending the right transaction? Does it contain the expected amount of money? (Check with <code>bitcoin-cli gettransaction</code> and be sure to look at the right <code>vout</code>.) Check your <code>vout</code>. Are you sending the right amount? Is it going to the right address? Finally, do the math to make sure the money balances. Does the value of the UTXO minus the amount being spent equal the expected transaction fee?</p>
<blockquote>
<p>:information_source:  <strong>NOTE - SEQUENCE:</strong> You may note that each input has a sequence number, set here to  4294967295, which is 0xFFFFFFFF. This is the last frontier of Bitcoin transactions, because it's a standard field in transactions that was originally intended for a specific purpose, but was never fully implemented. So now there's this integer sitting around in transactions that could be repurposed for other uses. And, in fact, it has been. As of this writing there are three different uses for the variable that's called <code>nSequence</code> in the Bitcoin Core code: it enables RBF, <code>nLockTime</code>, and relative timelocks. If there's nothing weird going on, <code>nSequence</code> will be set to 4294967295. Setting it to a lower value signals that special stuff is going on.</p>
</blockquote>
<h3 id="sign-the-raw-transaction"><a class="header" href="#sign-the-raw-transaction">Sign the Raw Transaction</a></h3>
<p>To date, your raw transaction is just something theoretical: you <em>could</em> send it, but nothing has been promised. You have to do a few things to get it out onto the network.</p>
<p>First, you need to sign your raw transaction:</p>
<pre><code>
$ bitcoin-cli signrawtransactionwithwallet $rawtxhex
{
  &quot;hex&quot;: &quot;02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000&quot;,
  &quot;complete&quot;: true
}
$ signedtx=&quot;02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000&quot;
</code></pre>
<p>Note that we captured the signed hex by hand, rather than trying to parse it out of the JSON object. A software package called &quot;JQ&quot; could do better, as we'll explain in an upcoming interlude.</p>
<h3 id="send-the-raw-transaction"><a class="header" href="#send-the-raw-transaction">Send the Raw Transaction</a></h3>
<p>You've now got a ready-to-go raw transaction, but it doesn't count until you actually put it on the network, which you do with the <code>sendrawtransaction</code> command. You'll get back a txid:</p>
<pre><code>$ bitcoin-cli sendrawtransaction $signedtx
a1fd550d1de727eccde6108c90d4ffec11ed83691e96e119d842b3f390e2f19a
</code></pre>
<p>You'll immediately see that the UTXO and its money have been removed from your wallet:</p>
<pre><code>$ bitcoin-cli listunspent
[
  {
    &quot;txid&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9141b72503639a13f190bf79acf6d76255d772360b788ac&quot;,
    &quot;amount&quot;: 0.00010000,
    &quot;confirmations&quot;: 23,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/1']02fd5740996d853ea51a6904cf03257fc11204b0179f344c49739ec5b20b39c9ba)#62rud39c&quot;,
    &quot;safe&quot;: true
  },
  {
    &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
    &quot;amount&quot;: 0.00022000,
    &quot;confirmations&quot;: 6,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
    &quot;safe&quot;: true
  }
]

$ bitcoin-cli getbalance
0.00032000
</code></pre>
<p>Soon <code>listtransactions</code> should show a confirmed transaction of category 'send&quot;.</p>
<pre><code> {
    &quot;address&quot;: &quot;n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi&quot;,
    &quot;category&quot;: &quot;send&quot;,
    &quot;amount&quot;: -0.00040000,
    &quot;vout&quot;: 0,
    &quot;fee&quot;: -0.00010000,
    &quot;confirmations&quot;: 1,
    &quot;trusted&quot;: true,
    &quot;txid&quot;: &quot;a1fd550d1de727eccde6108c90d4ffec11ed83691e96e119d842b3f390e2f19a&quot;,
    &quot;walletconflicts&quot;: [
    ],
    &quot;time&quot;: 1592608574,
    &quot;timereceived&quot;: 1592608574,
    &quot;bip125-replaceable&quot;: &quot;no&quot;,
    &quot;abandoned&quot;: false
  }
</code></pre>
<p>You can see that it matches the <code>txid</code> and the <code>recipient</code> address. Not only does it show the <code>amount</code> sent, but it also shows the transaction <code>fee</code>. And, it's already received a confirmation, because we offered a fee that would get it swept up into a block quickly.</p>
<p>Congratulations! You're now a few satoshis poorer!</p>
<h2 id="summary-creating-a-raw-transaction"><a class="header" href="#summary-creating-a-raw-transaction">Summary: Creating a Raw Transaction</a></h2>
<p>When money comes into your Bitcoin wallet, it remains as distinct amounts, called UTXOs. When you create a raw transaction to send that money back out, you use one or more UTXOs to fund it. You then can create a raw transaction, sign it, and send it on the Bitcoin network. However, this is just a foundation: you'll usually need to create a raw transaction with multiple outputs to actually send something on the bitcoin network!</p>
<h2 id="whats-next-12"><a class="header" href="#whats-next-12">What's Next?</a></h2>
<p>Step Back from &quot;Sending Bitcoin Transactions&quot; with <a href="04_2__Interlude_Using_JQ.html">Interlude: Using JQ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="43-creating-a-raw-transaction-with-named-arguments"><a class="header" href="#43-creating-a-raw-transaction-with-named-arguments">4.3 Creating a Raw Transaction with Named Arguments</a></h1>
<p>It can sometimes be daunting to figure out the right order for the arguments to a bitcoin-cli command. Fortunately, you can use <em>named arguments</em> as an alternative.</p>
<blockquote>
<p>:warning: <strong>VERSION WARNING:</strong> This is an innovation from Bitcoin Core v 0.14.0. If you used our setup scripts, that's what you should have, but double-check your version if you have any problems. There is also a bug in the <code>createrawtransaction</code> command's use of named arguments that will presumably be fixed in 0.14.1.</p>
</blockquote>
<h2 id="create-a-named-argument-alias"><a class="header" href="#create-a-named-argument-alias">Create a Named Argument Alias</a></h2>
<p>To use a named argument you must run <code>bitcoin-cli</code> with the <code>-named</code> argument. If you plan to do this regularly, you'll probably want to create an alias:</p>
<pre><code>alias bitcoin-cli=&quot;bitcoin-cli -named&quot;
</code></pre>
<p>As usual, that's for your ease of use, but we'll continue using the whole commands  to maintain clarity.</p>
<h2 id="test-out-a-named-argument"><a class="header" href="#test-out-a-named-argument">Test Out a Named Argument</a></h2>
<p>To learn what the names are for the arguments of a command, consult <code>bitcoin-cli help</code>. It will list the arguments in their proper order, but will now also give names for each of them.</p>
<p>For example, <code>bitcoin-cli help getbalance</code> lists these arguments:</p>
<ol>
<li>dummy [used to be account]</li>
<li>minconf</li>
<li>include_watchonly</li>
<li>avoid_reuse</li>
</ol>
<p>The following shows a traditional, unintuitive usage of <code>getbalance</code> using the minimum confirmation argument:</p>
<pre><code>$ bitcoin-cli getbalance &quot;*&quot; 1
</code></pre>
<p>With named arguments, you can clarify what you're doing, which also minimizes mistakes:</p>
<pre><code>$ bitcoin-cli -named getbalance minconf=1
</code></pre>
<h2 id="test-out-a-raw-transaction"><a class="header" href="#test-out-a-raw-transaction">Test Out a Raw Transaction</a></h2>
<p>Here's what the commands for sending a raw transaction would look like with named arguments:</p>
<pre><code>$ utxo_txid=$(bitcoin-cli listunspent | jq -r '.[0] | .txid') 
$ utxo_vout=$(bitcoin-cli listunspent | jq -r '.[0] | .vout')
$ recipient=&quot;n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi&quot;

$ rawtxhex=$(bitcoin-cli -named createrawtransaction inputs='''[ { &quot;txid&quot;: &quot;'$utxo_txid'&quot;, &quot;vout&quot;: '$utxo_vout' } ]''' outputs='''{ &quot;'$recipient'&quot;: 0.00001 }''')
$ bitcoin-cli -named decoderawtransaction hexstring=$rawtxhex 
{
  &quot;txid&quot;: &quot;2b59c31bc232c0399acee4c2a381b564b6fec295c21044fbcbb899ffa56c3da5&quot;,
  &quot;hash&quot;: &quot;2b59c31bc232c0399acee4c2a381b564b6fec295c21044fbcbb899ffa56c3da5&quot;,
  &quot;version&quot;: 2,
  &quot;size&quot;: 85,
  &quot;vsize&quot;: 85,
  &quot;weight&quot;: 340,
  &quot;locktime&quot;: 0,
  &quot;vin&quot;: [
    {
      &quot;txid&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
      &quot;vout&quot;: 0,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;&quot;,
        &quot;hex&quot;: &quot;&quot;
      },
      &quot;sequence&quot;: 4294967295
    }
  ],
  &quot;vout&quot;: [
    {
      &quot;value&quot;: 0.00001000,
      &quot;n&quot;: 0,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_DUP OP_HASH160 e7c1345fc8f87c68170b3aa798a956c2fe6a9eff OP_EQUALVERIFY OP_CHECKSIG&quot;,
        &quot;hex&quot;: &quot;76a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;pubkeyhash&quot;,
        &quot;addresses&quot;: [
          &quot;n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi&quot;
        ]
      }
    }
  ]
}

$ signedtx=$(bitcoin-cli -named signrawtransactionwithwallet hexstring=$rawtxhex | jq -r '.hex')
$ bitcoin-cli -named sendrawtransaction hexstring=$signedtx
e70dd2aa13422d12c222481c17ca21a57071f92ff86bdcffd7eaca71772ba172
</code></pre>
<p>Voila! You've sent out another raw transaction, but this time using named arguments for clarity and to reduce errors.</p>
<blockquote>
<p>:warning: <strong>VERSION WARNING:</strong> There is where the bug in Bitcoin Core 0.14 shows up: the 'inputs' argument for 'createrawtransaction' is misnamed 'transactions'. So, if you're on Bitcoin Core 0.14.0, substitute the named argument 'inputs' with 'transactions' for this and future examples. However, as of Bitcoin Core 0.14.1, this code should work as shown.</p>
</blockquote>
<h2 id="summary-creating-a-raw-transaction-with-named-arguments"><a class="header" href="#summary-creating-a-raw-transaction-with-named-arguments">Summary: Creating a Raw Transaction with Named Arguments</a></h2>
<p>By running <code>bitcoin-cli</code> with the <code>-named</code> flag, you can use named arguments rather than depending on ordered arguments. <code>bitcoin-cli help</code> will always show you the right name for each argument. This can result in more robust, easier-to-read, less error-prone code.</p>
<p><em>These docs will use named arguments for all future examples, for clarity and to establish best practices. However, it will also show all arguments in the correct order. So, if you prefer not to use named args, just strip out the '-named' flag and all of the &quot;name=&quot;s and the examples should continue to work correctly.</em></p>
<h2 id="whats-next-13"><a class="header" href="#whats-next-13">What's Next?</a></h2>
<p>Continue &quot;Sending Bitcoin Transactions&quot; with <a href="04_4_Sending_Coins_with_a_Raw_Transaction.html">§4.4: Sending Coins with Raw Transactions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-using-curl"><a class="header" href="#interlude-using-curl">Interlude: Using Curl</a></h1>
<p><code>bitcoin-cli</code> is ultimately just a wrapper. It's a way to interface with <code>bitcoind</code> from the command line, providing simplified access to its many RPC commands. But RPC can, of course, be accessed directly. That's what this interlude is about: directly connecting to RPC with the <code>curl</code> command.</p>
<p>It won't be used much in the future chapters, but it's an important building block that you can see as an alternative access to <code>bitcoind</code> is you so prefer.</p>
<h2 id="know-your-curl"><a class="header" href="#know-your-curl">Know Your Curl</a></h2>
<p><code>curl</code>, short for &quot;see URL&quot;, is a command-line tool that allows you to directly access URLs in a programmatic way. It's an easy way to interact with servers like <code>bitcoind</code> that listen to ports on the internet and that speak a variety of protocols. Curl is also available as a library for many programming languages, such as C, Java, PHP, and Python. So, once you know how to work with Curl, you'll have a strong foundation for using a lot of different API.</p>
<p>In order to use <code>curl</code> with <code>bitcoind</code>, you must know three things: the standard format, the user name and password, and the correct port.</p>
<h3 id="know-your-format"><a class="header" href="#know-your-format">Know Your Format</a></h3>
<p>The <code>bitcoin-cli</code> commands are all linked to RPC commands in <code>bitcoind</code>. That makes the transition from using <code>bitcoin-cli</code> to using <code>curl</code> very simple. In fact, if you look at any of the help pages for <code>bitcoin-cli</code>, you'll see that they list not only the <code>bitcoin-cli</code> commands, but also parallel <code>curl</code> commands. For example, here is <code>bitcoin-cli help getmininginfo</code>:</p>
<pre><code>$ bitcoin-cli help getmininginfo
getmininginfo

Returns a json object containing mining-related information.
Result:
{                              (json object)
  &quot;blocks&quot; : n,                (numeric) The current block
  &quot;currentblockweight&quot; : n,    (numeric, optional) The block weight of the last assembled block (only present if a block was ever assembled)
  &quot;currentblocktx&quot; : n,        (numeric, optional) The number of block transactions of the last assembled block (only present if a block was ever assembled)
  &quot;difficulty&quot; : n,            (numeric) The current difficulty
  &quot;networkhashps&quot; : n,         (numeric) The network hashes per second
  &quot;pooledtx&quot; : n,              (numeric) The size of the mempool
  &quot;chain&quot; : &quot;str&quot;,             (string) current network name (main, test, regtest)
  &quot;warnings&quot; : &quot;str&quot;           (string) any network and blockchain warnings
}

Examples:
&gt; bitcoin-cli getmininginfo 
&gt; curl --user myusername --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;: &quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: []}' -H 'content-type: text/plain;' http://127.0.0.1:8332/
</code></pre>
<p>And there's the <code>curl</code> command, at the end of the help screen! This somewhat lengthy command has four major parts: (1) a listing of your user name; (2) a <code>--data-binary</code> flag; (3) a JSON object that tells <code>bitcoind</code> what to do, including a JSON array of parameters; and (4) an HTTP header that includes the <code>bitcoind</code> URL.</p>
<p>When you are working with <code>curl</code>, most of these arguments to <code>curl</code> will stay the same from command to command; only the <code>method</code> and <code>params</code> entries in the JSON array will typically change. However, you need to know how to fill in your username and your URL address in order to make it work in the first place!</p>
<p><em>Whenever you're unsure about how to curl an RPC command, just look at the bitcoin-cli help and go from there.</em></p>
<h3 id="know-your-user-name"><a class="header" href="#know-your-user-name">Know Your User Name</a></h3>
<p>In order to speak with the <code>bitcoind</code> port, you need a user name and password. These were created as part of your initial Bitcoin setup, and can be found in <code>~/.bitcoin/bitcoin.conf</code>.</p>
<p>For example, here's our current setup:</p>
<pre><code>$ cat ~/.bitcoin/bitcoin.conf
server=1
dbcache=1536
par=1
maxuploadtarget=137
maxconnections=16
rpcuser=StandUp
rpcpassword=8eaf562eaf45c33c3328bc66008f2dd1
rpcallowip=127.0.0.1
debug=tor
prune=550
testnet=1
mintxfee=0.001
txconfirmtarget=1
[test]
rpcbind=127.0.0.1
rpcport=18332
[main]
rpcbind=127.0.0.1
rpcport=8332
[regtest]
rpcbind=127.0.0.1
rpcport=18443
</code></pre>
<p>Our user name is <code>StandUp</code> and our password is <code>8eaf562eaf45c33c3328bc66008f2dd1</code>.</p>
<blockquote>
<p><strong>WARNING:</strong> Clearly, it's not very secure to have this information in a plain text file. As of Bitcoin Core 0.12, you can instead omit the <code>rpcpassword</code> from your <code>bitcoin.conf</code> file, and have <code>bitcoind</code> generate a new cookie whenever it starts up. The downside of this is that it makes use of RPC commands by other applications, such as the ones detailed in this chapter, more difficult. So, we're going to stick with the plain <code>rpcuser</code> and <code>rpcpassword</code> information for now, but for production software, consider moving to cookies.</p>
</blockquote>
<p>The secure way to RPC with <code>bitcoind</code> is as follows:</p>
<pre><code>$ curl --user StandUp --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: [] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/
Enter host password for user 'bitcoinrpc':
</code></pre>
<p>As noted, you will be prompted for your password.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> Testnet uses a URL with port 18332 and mainnet uses a URL with port 8332. Take a look in your <code>bitcoin.conf</code>, it's all laid out there.</p>
</blockquote>
<p>The insecure way to do so is as follows:</p>
<pre><code>$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: [] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/
</code></pre>
<blockquote>
<p><strong>WARNING:</strong> Entering your password on the command line may put your password into the process table and/or save it into a history. This is even less recommended than putting it in a file, except for testing on testnet. If you want to do it anywhere else, make sure you know what you're doing!</p>
</blockquote>
<h3 id="know-your-command--parameters"><a class="header" href="#know-your-command--parameters">Know Your Command &amp; Parameters</a></h3>
<p>With all of that in hand, you're ready to send off standard RPC commands with <code>curl</code> ... but you still need to know how to incorporate the two elements that tend to change in the <code>curl</code> command.</p>
<p>The first is <code>method</code>, which is the RPC method being used. This should generally match the command names you've been feeding into <code>bitcoin-cli</code> for ages.</p>
<p>The second is <code>params</code>, which is a JSON array of parameters. These are the same as the arguments (or named arguments) that you've been using. They're also the most confusing part of <code>curl</code>, in large part because they're a structured array rather than a simple list.</p>
<p>Here's what some parameter arrays will look like:</p>
<ul>
<li><code>[]</code> — An empty array</li>
<li><code>[&quot;000b4430a7a2ba60891b01b718747eaf9665cb93fbc0c619c99419b5b5cf3ad2&quot;]</code> — An array with data</li>
<li><code>[&quot;'$signedhex'&quot;]</code> — An array with a variable</li>
<li><code>[6, 9999999]</code> — An array with two parameters</li>
<li><code>{}</code> - An empty object</li>
<li><code>[''[ { &quot;txid&quot;: &quot;'$utxo_txid'&quot;, &quot;vout&quot;: '$utxo_vout' } ]'', ''{ &quot;'$recipient'&quot;: 0.298, &quot;'$changeaddress'&quot;: 1.0}'']</code> — An array with an array containing an object and a bare object</li>
</ul>
<h2 id="get-information"><a class="header" href="#get-information">Get Information</a></h2>
<p>You can now send your first <code>curl</code> command by accessing the <code>getmininginfo</code> RPC:</p>
<pre><code>$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: [] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/
{&quot;result&quot;:{&quot;blocks&quot;:1772428,&quot;difficulty&quot;:10178811.40698772,&quot;networkhashps&quot;:91963587385939.06,&quot;pooledtx&quot;:61,&quot;chain&quot;:&quot;test&quot;,&quot;warnings&quot;:&quot;Warning: unknown new rules activated (versionbit 28)&quot;},&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;}
</code></pre>
<p>Note that we provided the method, <code>getmininginfo</code>, and the parameter, <code>[]</code>, but that everything else was the standard <code>curl</code> command line.</p>
<blockquote>
<p><strong>WARNING:</strong> If you get a result like &quot;Failed to connect to 127.0.0.1 port 8332: Connection refused&quot;, be sure that a line like <code>rpcallowip=127.0.0.1</code> is in your ~/.bitcoin/bitcoin.conf. If things still don't work, be sure that you're allowing access to port 18332 (or 8332) from localhost. Our standard setup from <a href="02_0_Setting_Up_a_Bitcoin-Core_VPS.html">Chapter Two: Creating a Bitcoin-Core VPS</a> should do all of this.</p>
</blockquote>
<p>The result is another JSON array, which is unfortunately ugly to read if you're using <code>curl</code> by hand. Fortunately, you can clean it up  simply by piping it through <code>jq</code>:</p>
<pre><code>$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: [] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.'
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   295  100   218  100    77  72666  25666 --:--:-- --:--:-- --:--:-- 98333
{
  &quot;result&quot;: {
    &quot;blocks&quot;: 1772429,
    &quot;difficulty&quot;: 10178811.40698772,
    &quot;networkhashps&quot;: 90580030969896.44,
    &quot;pooledtx&quot;: 4,
    &quot;chain&quot;: &quot;test&quot;,
    &quot;warnings&quot;: &quot;Warning: unknown new rules activated (versionbit 28)&quot;
  },
  &quot;error&quot;: null,
  &quot;id&quot;: &quot;curltest&quot;
}
</code></pre>
<p>You'll see a bit of connectivity reporting as the data is downloaded, then when that data hits <code>jq</code>, everything will be output in a correctly indented form. (We'll be omitting the download information in future examples.)</p>
<h2 id="manipulate-your-wallet"><a class="header" href="#manipulate-your-wallet">Manipulate Your Wallet</a></h2>
<p>Though you're accessing <code>bitcoind</code> directly, you'll still get access to wallet functionality, because that's largely stored in <code>bitcoind</code> itself.</p>
<h3 id="look-up-addresses"><a class="header" href="#look-up-addresses">Look Up Addresses</a></h3>
<p>Use the <code>getaddressesbylabel</code> RPC to list all of your current addresses:</p>
<pre><code>$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getaddressesbylabel&quot;, &quot;params&quot;: [&quot;&quot;] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.'
{
  &quot;result&quot;: {
    &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;: {
      &quot;purpose&quot;: &quot;receive&quot;
    },
    &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;: {
      &quot;purpose&quot;: &quot;receive&quot;
    },
    &quot;moKVV6XEhfrBCE3QCYq6ppT7AaMF8KsZ1B&quot;: {
      &quot;purpose&quot;: &quot;receive&quot;
    },
    &quot;mwJL7cRiW2bUnY81r1thSu3D4jtMmwyU6d&quot;: {
      &quot;purpose&quot;: &quot;receive&quot;
    },
    &quot;tb1q5gnwrh7ss5mmqt0qfan85jdagmumnatcscwpk6&quot;: {
      &quot;purpose&quot;: &quot;receive&quot;
    },
    &quot;tb1qmtucvjtga68kgrvkl7q05x4t9lylxhku7kqdpr&quot;: {
      &quot;purpose&quot;: &quot;receive&quot;
    }
  },
  &quot;error&quot;: null,
  &quot;id&quot;: &quot;curltest&quot;
}
</code></pre>
<p>This is our first example of a real parameter, <code>&quot;&quot;</code>. This is the required <code>label</code> parameter for <code>getaddressesbylabel</code>, but all of our addresses are under the default label, so nothing special was required here.</p>
<p>The result is a list of all the addresses that have been used by this wallet ... some of which presumably contain funds.</p>
<h3 id="look-up-funds"><a class="header" href="#look-up-funds">Look Up Funds</a></h3>
<p>Use the <code>listunspent</code> RPC to list the funds that you have available:</p>
<pre><code>$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;listunspent&quot;, &quot;params&quot;: [] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.'
{
  &quot;result&quot;: [
    {
      &quot;txid&quot;: &quot;e7071092dee0b2ae584bf6c1ee3c22164304e3a17feea7a32c22db5603cd6a0d&quot;,
      &quot;vout&quot;: 1,
      &quot;address&quot;: &quot;mk9ry5VVy8mrA8SygxSQQUDNSSXyGFot6h&quot;,
      &quot;scriptPubKey&quot;: &quot;76a91432db726320e4ad170c9c1ee83cd4d8a243c3435988ac&quot;,
      &quot;amount&quot;: 0.0009,
      &quot;confirmations&quot;: 4,
      &quot;spendable&quot;: true,
      &quot;solvable&quot;: true,
      &quot;desc&quot;: &quot;pkh([d6043800/0'/1'/2']02881697d252d8bf181d08c58de1f02aec088cd2d468fc5fd888c6e39909f7fabf)#p6k7dptk&quot;,
      &quot;safe&quot;: true
    },
    {
      &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
      &quot;vout&quot;: 0,
      &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
      &quot;label&quot;: &quot;&quot;,
      &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
      &quot;amount&quot;: 0.00022,
      &quot;confirmations&quot;: 19,
      &quot;spendable&quot;: true,
      &quot;solvable&quot;: true,
      &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
      &quot;safe&quot;: true
    }
  ],
  &quot;error&quot;: null,
  &quot;id&quot;: &quot;curltest&quot;
}
</code></pre>
<p>This is almost exactly the same output that you receive when you type <code>bitcoin-cli listunspent</code>, showing how closely tied the two interfaces are. If no cleanup or extra help is needed, then <code>bitcoin-cli</code> just outputs the RPC. Easy!</p>
<h3 id="create-an-address-1"><a class="header" href="#create-an-address-1">Create an Address</a></h3>
<p>After you know where your funds are, the next step in crafting a transaction is to get a change address. By now you've probably got the hang of this, and you know that for simple RPC commands, all you need to do is adjust the <code>method</code> is the <code>curl</code> command:</p>
<pre><code>$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getrawchangeaddress&quot;, &quot;params&quot;: [&quot;&quot;, &quot;legacy&quot;] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.'
{
  &quot;result&quot;: &quot;mrSqN37TPs89GcidSZTvXmMzjxoJZ6RKoz&quot;,
  &quot;error&quot;: null,
  &quot;id&quot;: &quot;curltest&quot;
}
</code></pre>
<blockquote>
<p><strong>WARNING:</strong> The parameters order is important when you are sending RPC commands using curl. For example here, if we had sent <code>&quot;params&quot;: [&quot;legacy&quot;]</code> instead of <code>&quot;params&quot;: [&quot;&quot;, &quot;legacy&quot;]</code>, we would get a <code>bech32</code> address with a label of <code>&quot;legacy&quot;</code> instead of a <code>legacy</code> address, so pay attention to the order.</p>
</blockquote>
<p>At this point, we can even revert to our standard practice of saving results to variables with additional help from <code>jq</code>:</p>
<pre><code>$ changeaddress=$(curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getrawchangeaddress&quot;, &quot;params&quot;: [&quot;&quot;, &quot;legacy&quot;] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.result')
$ echo $changeaddress
mqdfnjgWr2r3sCCeuTDfe8fJ1CnycF2e6R
</code></pre>
<p>No need to worry about the downloading info. It'll go to <code>STDERR</code> and be displayed on your screen, while the results go to <code>STDOUT</code> and are saved in your variable.</p>
<h2 id="create-a-transaction"><a class="header" href="#create-a-transaction">Create a Transaction</a></h2>
<p>You're now ready to create a transaction with <code>curl</code>.</p>
<h3 id="ready-your-variables"><a class="header" href="#ready-your-variables">Ready Your Variables</a></h3>
<p>Just as with <code>bitcoin-cli</code>, in order to create a transaction by curling RPC commands, you should first save your variables. The only change here is that <code>curl</code> creates a JSON object that includes a <code>result</code> key-value, so you always need to pipe through the <code>.result</code> tag before you do anything else.</p>
<p>This example sets up our variables for using the 1.2985 BTC in funds listed in the first unspent transaction above:</p>
<pre><code>$ utxo_txid=$(curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;listunspent&quot;, &quot;params&quot;: [] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.result | .[0] | .txid')
$ utxo_vout=$(curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;listunspent&quot;, &quot;params&quot;: [] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.result | .[0] | .vout')
$ recipient=mwCwTceJvYV27KXBc3NJZys6CjsgsoeHmf
$ changeaddress=$(curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getrawchangeaddress&quot;, &quot;params&quot;: [&quot;legacy&quot;] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.result')

$ echo $utxo_txid
e7071092dee0b2ae584bf6c1ee3c22164304e3a17feea7a32c22db5603cd6a0d
$ echo $utxo_vout
1
$ echo $recipient
mwCwTceJvYV27KXBc3NJZys6CjsgsoeHmf
$ echo $changeaddress
n2jf3MzeFpFGa7wq8rXKVnVuv5FoNSJZ1N
</code></pre>
<h3 id="create-the-transaction"><a class="header" href="#create-the-transaction">Create the Transaction</a></h3>
<p>The transaction created with <code>curl</code> is very similar to the transaction created with <code>bitcoin-cli</code>, but with a few subtle differences:</p>
<pre><code>$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;createrawtransaction&quot;, &quot;params&quot;: [''[ { &quot;txid&quot;: &quot;'$utxo_txid'&quot;, &quot;vout&quot;: '$utxo_vout' } ]'', ''{ &quot;'$recipient'&quot;: 0.0003, &quot;'$changeaddress'&quot;: 0.0005}'']}' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.'
{
  &quot;result&quot;: &quot;02000000010d6acd0356db222ca3a7ee7fa1e3044316223ceec1f64b58aeb2e0de921007e70100000000ffffffff0230750000000000001976a914ac19d3fd17710e6b9a331022fe92c693fdf6659588ac50c30000000000001976a9147021efec134057043386decfaa6a6aa4ee5f19eb88ac00000000&quot;,
  &quot;error&quot;: null,
  &quot;id&quot;: &quot;curltest&quot;
}
</code></pre>
<p>The heart of the transaction is, of course, the <code>params</code> JSON array, which we're putting to full use for the first time.</p>
<p>Note that the entire <code>params</code> is lodged in <code>[]</code>s to mark the parameters array.</p>
<p>We've also varied up the quoting from how things worked in <code>bitcoin-cli</code>, to start and end each array and object within the <code>params</code> array with <code>''</code> instead of our traditional <code>'''</code>. That's because the entire set of JSON arguments already has a <code>'</code> around it. As usual, just take a look at the bizarre shell quoting and get used to it.</p>
<p>However, there's one last thing of note in this example, and it can be <em>maddening</em> if you miss it. When you executed a <code>createrawtransaction</code> command with <code>bitcoin-cli</code> the JSON array of inputs and the JSON object of outputs were each distinct parameters, so they were separated by a space. Now, because they're part of that <code>params</code> JSON array, they're separated by a comma (<code>,</code>). Miss that and you'll get a <code>parse error</code> without much additional information.</p>
<blockquote>
<p><strong>WARNING:</strong> Ever having troubles debugging your <code>curl</code>? Add the argument <code>--trace-ascii /tmp/foo</code>. Full information on what's being sent to the server will be saved in <code>/tmp/foo</code> (or whatever file name you provide).</p>
</blockquote>
<p>Having verified that things work, you probably want to save the hex code into a variable:</p>
<pre><code>$ hexcode=$(curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;createrawtransaction&quot;, &quot;params&quot;: [''[ { &quot;txid&quot;: &quot;'$utxo_txid'&quot;, &quot;vout&quot;: '$utxo_vout' } ]'', ''{ &quot;'$recipient'&quot;: 0.0003, &quot;'$changeaddress'&quot;: 0.0005}'']}' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.result')
</code></pre>
<h3 id="sign-and-send"><a class="header" href="#sign-and-send">Sign and Send</a></h3>
<p>Signing and sending your transaction using <code>curl</code> is an easy use of the <code>signrawtransactionwithwallet</code> and <code>sendrawtransaction</code> RPC:</p>
<pre><code>$ signedhex=$(curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;signrawtransactionwithwallet&quot;, &quot;params&quot;: [&quot;'$hexcode'&quot;] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.result | .hex')

$ curl --user StandUp:8eaf562eaf45c33c3328bc66008f2dd1 --data-binary '{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;sendrawtransaction&quot;, &quot;params&quot;: [&quot;'$signedhex'&quot;] }' -H 'content-type: text/plain;' http://127.0.0.1:18332/ | jq -r '.'
{
  &quot;result&quot;: &quot;eb84c5008038d760805d4d9644ace67849542864220cb2685a1ea2c64176b82d&quot;,
  &quot;error&quot;: null,
  &quot;id&quot;: &quot;curltest&quot;
}
</code></pre>
<h2 id="summary-accessing-bitcoind-with-curl"><a class="header" href="#summary-accessing-bitcoind-with-curl">Summary: Accessing Bitcoind with Curl</a></h2>
<p>Having finished this section, you may feel that accessing <code>bitcoind</code> via <code>curl</code> is very much like accessing it through <code>bitcoin-cli</code> ... but more cumbersome. And, you'd be right. <code>bitcoin-cli</code> has pretty complete RPC functionality, so anything that you do through <code>curl</code> you can probably do through <code>bitcoin-cli</code>. Which is why we're going to continue concentrating on <code>bitcoin-cli</code> following this digression.</p>
<p>But there are still reasons you'd use <code>curl</code> instead of <code>bitcoin-cli</code>:</p>
<p><em>What is the power of curl?</em> Most obviously, <code>curl</code> takes out one level of indirection. Instead of working with <code>bitcoin-cli</code> which sends RPC commands to <code>bitcoind</code>, you're sending those RPC commands directly. This allows for more robust programming, because you don't have to worry about what unexpected things that <code>bitcoin-cli</code> might do or how it might change over time. However, you're also taking your first steps toward using a more comprehensive programming language than the poor options offered by a shell script. As you'll see in the last few chapters of this, you might actually see curl libraries are other functions to access the RPC commands in a variety of programming languages: but that's still a long ways away.</p>
<h2 id="whats-next-14"><a class="header" href="#whats-next-14">What's Next?</a></h2>
<p>Learn one more way to &quot;Send Bitcoin Transactions&quot; with <a href="04_5_Sending_Coins_with_Automated_Raw_Transactions.html">§4.5 Sending Coins with Automated Raw Transactions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="44-sending-coins-with-raw-transactions"><a class="header" href="#44-sending-coins-with-raw-transactions">4.4: Sending Coins with Raw Transactions</a></h1>
<p>As noted at the start of this chapter, the <code>bitcoin-cli</code> interface offers three major ways to send coins. <a href="04_1_Sending_Coins_The_Easy_Way.html">§4.1</a> talked about sending them the first way, using the <code>sendtoaddress</code> command. Since then, we've been building details on how to send coins a second way, with raw transactions. <a href="04_2_Creating_a_Raw_Transaction.html">§4.2</a> taught how to create a raw transaction, an <a href="04_2__Interlude_Using_JQ.html">Interlude</a> explained JQ, and <a href="04_3_Creating_a_Raw_Transaction_with_Named_Arguments.html">§4.3</a> demonstrated named arguments.</p>
<p>We can now put those together and actually send funds using a raw transaction.</p>
<h2 id="create-a-change-address"><a class="header" href="#create-a-change-address">Create a Change Address</a></h2>
<p>Our sample raw transaction in section §4.2 was very simplistic: we sent the entirety of a UTXO to a new address. More frequently, you'll want to send someone an amount of money that doesn't match a UTXO. But, you'll recall that the excess money from a UTXO that's not sent to your recipient just becomes a transaction fee. So, how do you send someone just part of a UTXO, while keeping the rest for yourself?</p>
<p>The solution is to <em>send</em> the rest of the funds to a second address, a change address that you've created in your wallet specifically to receive them:</p>
<pre><code>$ changeaddress=$(bitcoin-cli getrawchangeaddress legacy)
$ echo $changeaddress
mk9ry5VVy8mrA8SygxSQQUDNSSXyGFot6h
</code></pre>
<p>Note that this uses a new function: <code>getrawchangeaddress</code>. It's largely the same as <code>getnewaddress</code> but is optimized for use as a change address in a raw transaction, so it doesn't do things like make entries in your address book. We again selected the <code>legacy</code> address, instead of going with the default of <code>bech32</code>, simply for consistency. This is a situation where it would have been entirely safe to generate a default Bech32 address, just by using <code>bitcoin-cli getrawchangeaddress</code>, because it would being sent and received by you on your Bitcoin Core node which fully supports this. But, hobgoblins; we'll shift this over to Bech32 as well in <a href="04_6_Creating_a_Segwit_Transaction.html">§4.6</a>.</p>
<p>You now have an additional address inside your wallet, so that you can receive change from a UTXO! In order to use it, you'll need to create a raw transaction with two outputs.</p>
<h2 id="pick-sufficient-utxos"><a class="header" href="#pick-sufficient-utxos">Pick Sufficient UTXOs</a></h2>
<p>Our sample raw transaction was simple in another way: it assumed that there was enough money in a single UTXO to cover the transaction. Often this will be the case, but sometimes you'll want to create transactions that spends more money than you have in a single UTXO. To do so, you must create a raw transaction with two (or more) inputs.</p>
<h2 id="write-a-real-raw-transaction"><a class="header" href="#write-a-real-raw-transaction">Write a Real Raw Transaction</a></h2>
<p>To summarize: creating a real raw transaction to send coins will sometimes require multiple inputs and will almost always require multiple outputs, one of which is a change address. We'll be creating that sort of more realistic transaction here, in a new example that shows a real-life example of sending funds via Bitcoin's second methodology, raw transactions.</p>
<p>We're going to use our 0th and 2nd UTXOs:</p>
<pre><code>$ bitcoin-cli listunspent
[
[
  {
    &quot;txid&quot;: &quot;0619fecf6b2668fab1308fbd7b291ac210932602a6ac6b8cc11c7ae22c43701e&quot;,
    &quot;vout&quot;: 1,
    &quot;address&quot;: &quot;mwJL7cRiW2bUnY81r1thSu3D4jtMmwyU6d&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a914ad1ed1c5971b2308f89c1362d4705d020a40e8e788ac&quot;,
    &quot;amount&quot;: 0.00899999,
    &quot;confirmations&quot;: 1,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/4']03eae28c93035f95a620dd96e1822f2a96e0357263fa1f87606a5254d5b9e6698f)#wwnfx2sp&quot;,
    &quot;safe&quot;: true
  },
  {
    &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
    &quot;amount&quot;: 0.00022000,
    &quot;confirmations&quot;: 15,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
    &quot;safe&quot;: true
  },  
  {
    &quot;txid&quot;: &quot;0df23a9dba49e822bbc558f15516f33021a64a5c2e48962cec541e0bcc79854d&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mwJL7cRiW2bUnY81r1thSu3D4jtMmwyU6d&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a914ad1ed1c5971b2308f89c1362d4705d020a40e8e788ac&quot;,
    &quot;amount&quot;: 0.00100000,
    &quot;confirmations&quot;: 1,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/4']03eae28c93035f95a620dd96e1822f2a96e0357263fa1f87606a5254d5b9e6698f)#wwnfx2sp&quot;,
    &quot;safe&quot;: true
   }
]

</code></pre>
<p>In our example, we're going to send .009 BTC, which is (barely) larger than either of our UTXOs. This requires combining them, then using our change address to retrieve the unspent funds.</p>
<h3 id="set-up-your-variables"><a class="header" href="#set-up-your-variables">Set Up Your Variables</a></h3>
<p>We already have <code>$changeaddress</code> and <code>$recipient</code> variables from previous examples:</p>
<pre><code>$ echo $changeaddress
mk9ry5VVy8mrA8SygxSQQUDNSSXyGFot6h
$ echo $recipient
n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi
</code></pre>
<p>We also need to record the txid and vout for each of our two UTXOs. Having identified the UTXOs that we want to spend, we can use our JQ techniques to make sure accessing them is error free:</p>
<pre><code>$ utxo_txid_1=$(bitcoin-cli listunspent | jq -r '.[0] | .txid')
$ utxo_vout_1=$(bitcoin-cli listunspent | jq -r '.[0] | .vout')
$ utxo_txid_2=$(bitcoin-cli listunspent | jq -r '.[2] | .txid')
$ utxo_vout_2=$(bitcoin-cli listunspent | jq -r '.[2] | .vout')
</code></pre>
<h3 id="write-the-transaction"><a class="header" href="#write-the-transaction">Write the Transaction</a></h3>
<p>Writing the actual raw transaction is surprisingly simple. All you need to do is include an additional, comma-separated JSON object in the JSON array of inputs and an additional, comma-separated key-value pair in the JSON object of outputs.</p>
<p>Here's the example. Note the multiple inputs after the <code>inputs</code> arg and the multiple outputs after the <code>outputs</code> arg.</p>
<pre><code>$ rawtxhex2=$(bitcoin-cli -named createrawtransaction inputs='''[ { &quot;txid&quot;: &quot;'$utxo_txid_1'&quot;, &quot;vout&quot;: '$utxo_vout_1' }, { &quot;txid&quot;: &quot;'$utxo_txid_2'&quot;, &quot;vout&quot;: '$utxo_vout_2' } ]''' outputs='''{ &quot;'$recipient'&quot;: 0.009, &quot;'$changeaddress'&quot;: 0.0009 }''')
</code></pre>
<p>We were <em>very</em> careful figuring out our money math. These two UTXOs contain 0.00999999 BTC. After sending 0.009 BTC, we'll have .00099999 BTC left. We chose .00009999 BTC the transaction fee. To accommodate that fee, we set our change to .0009 BTC. If we'd messed up our math and instead set our change to .00009 BTC, that additional BTC would be lost to the miners! If we'd forgot to make change at all, then the whole excess would have disappeared. So, again, <em>be careful</em>. </p>
<p>Fortunately, we can triple-check with the <code>btctxfee</code> alias from the JQ Interlude:</p>
<pre><code>$ ./txfee-calc.sh $rawtxhex2
.00009999
</code></pre>
<h3 id="finish-it-up"><a class="header" href="#finish-it-up">Finish It Up</a></h3>
<p>You can now sign, seal, and deliver your transaction, and it's yours (and the faucet's):</p>
<pre><code>$ signedtx2=$(bitcoin-cli -named signrawtransactionwithwallet hexstring=$rawtxhex2 | jq -r '.hex')
$ bitcoin-cli -named sendrawtransaction hexstring=$signedtx2
e7071092dee0b2ae584bf6c1ee3c22164304e3a17feea7a32c22db5603cd6a0d
</code></pre>
<h3 id="wait"><a class="header" href="#wait">Wait</a></h3>
<p>As usual, your money will be in flux for a while: the change will be unavailable until the transaction actually gets confirmed and a new UTXO is given to you.</p>
<p>But, in 10 minutes or less (probably), you'll have your remaining money back and fully spendable again. For now, we're still waiting:</p>
<pre><code>$ bitcoin-cli listunspent
[
  {
    &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
    &quot;amount&quot;: 0.00022000,
    &quot;confirmations&quot;: 15,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
    &quot;safe&quot;: true
  }
]
</code></pre>
<p>And the change will eventuall arrive:</p>
<pre><code>[
  {
    &quot;txid&quot;: &quot;e7071092dee0b2ae584bf6c1ee3c22164304e3a17feea7a32c22db5603cd6a0d&quot;,
    &quot;vout&quot;: 1,
    &quot;address&quot;: &quot;mk9ry5VVy8mrA8SygxSQQUDNSSXyGFot6h&quot;,
    &quot;scriptPubKey&quot;: &quot;76a91432db726320e4ad170c9c1ee83cd4d8a243c3435988ac&quot;,
    &quot;amount&quot;: 0.00090000,
    &quot;confirmations&quot;: 1,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/1'/2']02881697d252d8bf181d08c58de1f02aec088cd2d468fc5fd888c6e39909f7fabf)#p6k7dptk&quot;,
    &quot;safe&quot;: true
  },
  {
    &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
    &quot;amount&quot;: 0.00022000,
    &quot;confirmations&quot;: 16,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;pkh([d6043800/0'/0'/3']0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
    &quot;safe&quot;: true
  }
]
</code></pre>
<p>This also might be a good time to revisit a blockchain explorer, so that you can see more intuitively how the inputs, outputs, and transaction fee are all laid out: <a href="https://live.blockcypher.com/btc-testnet/tx/e7071092dee0b2ae584bf6c1ee3c22164304e3a17feea7a32c22db5603cd6a0d/">e7071092dee0b2ae584bf6c1ee3c22164304e3a17feea7a32c22db5603cd6a0d</a>.</p>
<h2 id="summary-sending-coins-with-raw-transactions"><a class="header" href="#summary-sending-coins-with-raw-transactions">Summary: Sending Coins with Raw Transactions</a></h2>
<p>To send coins with raw transactions, you need to create a raw transaction with one or more inputs (to have sufficient funds) and one or more outputs (to retrieve change). Then, you can follow your normal procedure of using <code>createrawtransaction</code> with named arguments and JQ, as laid out in previous sections.</p>
<blockquote>
<p>:fire: <em><strong>What is the power of sending coins with raw transactions?</strong></em></p>
</blockquote>
<blockquote>
<p><em>The advantages.</em> It gives you the best control. If your goal is to write a more intricate Bitcoin script or program, you'll probably use raw transactions so that you know exactly what's going on. This is also the <em>safest</em> situation to use raw transactions, because you can programmatically ensure that you don't make mistakes.</p>
</blockquote>
<blockquote>
<p><em>The disadvantages.</em> It's easy to lose money. There are no warnings, no safeguards, and no programmatic backstops unless you write them. It's also arcane. The formatting is obnoxious, even using the easy-to-use <code>bitcoin-cli</code> interface, and you have to do a lot of lookup and calculation by hand.</p>
</blockquote>
<h2 id="whats-next-15"><a class="header" href="#whats-next-15">What's Next?</a></h2>
<p>See another alternative way to input commands with <a href="04_4__Interlude_Using_Curl.html">Interlude: Using Curl</a>.</p>
<p>Or, you prefer to skip what's frankly a digression, learn one more way to &quot;Send Bitcoin Transactions&quot; with <a href="04_5_Sending_Coins_with_Automated_Raw_Transactions.html">§4.5 Sending Coins with Automated Raw Transactions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="45-sending-coins-with-automated-raw-transactions"><a class="header" href="#45-sending-coins-with-automated-raw-transactions">4.5: Sending Coins with Automated Raw Transactions</a></h1>
<p>This chapter lays out three ways to send funds via Bitcoin's cli interface. <a href="04_1_Sending_Coins_The_Easy_Way.html">§4.1</a> described how to do so with a simple command, and <a href="04_4_Sending_Coins_with_a_Raw_Transaction.html">§4.4</a> detailed how to use a more dangerous raw transaction. This final section splits the difference by showing how to make raw transactions simpler and safer. </p>
<h2 id="let-bitcoin-calculate-for-you"><a class="header" href="#let-bitcoin-calculate-for-you">Let Bitcoin Calculate For You</a></h2>
<p>The methodology for automated raw transactions is simple: you create a raw transaction, but you use the <code>fundrawtransaction</code> command to ask the bitcoind to run the calculations for you.</p>
<p>In order to use this command, you'll need to ensure that your ~/.bitcoin/bitcoin.conf file contains rational variables for calculating transaction fees. Please see <a href="04_1_Sending_Coins_The_Easy_Way.html">§4.1: Sending Coins The Easy Way</a> for more information on this.</p>
<p>For very conservative numbers, we suggested adding the following to the <code>bitcoin.conf</code>:</p>
<pre><code>mintxfee=0.0001
txconfirmtarget=6
</code></pre>
<p>To keep the tutorial moving along (and more generally to move money fast) we suggested the following:</p>
<pre><code>mintxfee=0.001
txconfirmtarget=1
</code></pre>
<h2 id="create-a-bare-bones-raw-transaction"><a class="header" href="#create-a-bare-bones-raw-transaction">Create a Bare Bones Raw Transaction</a></h2>
<p>To use <code>fundrawtransaction</code> you first need to create a bare-bones raw transaction that lists <em>no</em> inputs and <em>no</em> change address. You'll just list your recipient and how much you want to send them, in this case <code>$recipient</code> and <code>0.0002</code> BTC.</p>
<pre><code>$ recipient=n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi
$ unfinishedtx=$(bitcoin-cli -named createrawtransaction inputs='''[]''' outputs='''{ &quot;'$recipient'&quot;: 0.0002 }''')
</code></pre>
<h2 id="fund-your-bare-bones-transaction"><a class="header" href="#fund-your-bare-bones-transaction">Fund Your Bare Bones Transaction</a></h2>
<p>You then tell <code>bitcoin-cli</code> to fund that bare-bones transaction:</p>
<pre><code>$ bitcoin-cli -named fundrawtransaction hexstring=$unfinishedtx
{
  &quot;hex&quot;: &quot;02000000012db87641c6a21e5a68b20c226428544978e6ac44964d5d8060d7388000c584eb0100000000feffffff02204e0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac781e0000000000001600140cc9cdcf45d4ea17f5227a7ead52367aad10a88400000000&quot;,
  &quot;fee&quot;: 0.00022200,
  &quot;changepos&quot;: 1
}
</code></pre>
<p>That provides a lot of useful information, but once you're confident with how it works, you'll want to use JQ to save your hex to a variable, as usual:</p>
<pre><code>$ rawtxhex3=$(bitcoin-cli -named fundrawtransaction hexstring=$unfinishedtx | jq -r '.hex')
</code></pre>
<h2 id="verify-your-funded-transaction"><a class="header" href="#verify-your-funded-transaction">Verify Your Funded Transaction</a></h2>
<p>It seems like magic, so the first few times you use <code>fundrawtransaction</code>, you'll probably want to verify it.</p>
<p>Running <code>decoderawtransaction</code> will show that the raw transaction is now laid out correctly, using one or more of your UTXOs and sending excess funds back to a change address:</p>
<pre><code>$ bitcoin-cli -named decoderawtransaction hexstring=$rawtxhex3
{
  &quot;txid&quot;: &quot;b3b4c2057dbfbef6690e975ede92fde805ddea13c730f58401939a52c9ac1b99&quot;,
  &quot;hash&quot;: &quot;b3b4c2057dbfbef6690e975ede92fde805ddea13c730f58401939a52c9ac1b99&quot;,
  &quot;version&quot;: 2,
  &quot;size&quot;: 116,
  &quot;vsize&quot;: 116,
  &quot;weight&quot;: 464,
  &quot;locktime&quot;: 0,
  &quot;vin&quot;: [
    {
      &quot;txid&quot;: &quot;eb84c5008038d760805d4d9644ace67849542864220cb2685a1ea2c64176b82d&quot;,
      &quot;vout&quot;: 1,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;&quot;,
        &quot;hex&quot;: &quot;&quot;
      },
      &quot;sequence&quot;: 4294967294
    }
  ],
  &quot;vout&quot;: [
    {
      &quot;value&quot;: 0.00020000,
      &quot;n&quot;: 0,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_DUP OP_HASH160 e7c1345fc8f87c68170b3aa798a956c2fe6a9eff OP_EQUALVERIFY OP_CHECKSIG&quot;,
        &quot;hex&quot;: &quot;76a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;pubkeyhash&quot;,
        &quot;addresses&quot;: [
          &quot;n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi&quot;
        ]
      }
    },
    {
      &quot;value&quot;: 0.00007800,
      &quot;n&quot;: 1,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;0 a782f4c6e1e75a5b24f3d675d6f11b5ebf3b2142&quot;,
        &quot;hex&quot;: &quot;0014a782f4c6e1e75a5b24f3d675d6f11b5ebf3b2142&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;witness_v0_keyhash&quot;,
        &quot;addresses&quot;: [
          &quot;tb1q57p0f3hpuad9kf8n6e6adugmt6lnkg2zzr592r&quot;
        ]
      }
    }
  ]
}
</code></pre>
<p>One thing of interest here is the change address, which is the second <code>vout</code>. Note that it's a <code>tb1</code> address, which means that it's Bech32; when we gave Bitcoin Core the total ability to manage our change, it did so using its default address type, Bech32, and it worked fine. That's why our change to SegWit addresses in <a href="04_6_Creating_a_Segwit_Transaction.html">§4.6</a> really isn't that big of a deal, but there are some gotchas for wider usage, which we'll talk about there.</p>
<p>Though we saw the fee in the <code>fundrawtransaction</code> output, it's not visible here. However, you can verify it with the <code>txfee-calc.sh</code> JQ script created in the <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/04_2__Interlude_Using_JQ.md">JQ Interlude</a>:</p>
<pre><code>$ ~/txfee-calc.sh $rawtxhex3
.000222
</code></pre>
<p>Finally, you can use <code>getaddressinfo</code> to see that the generated change address really belongs to you:</p>
<pre><code>$ bitcoin-cli -named getaddressinfo address=tb1q57p0f3hpuad9kf8n6e6adugmt6lnkg2zzr592r
{
  &quot;address&quot;: &quot;tb1q57p0f3hpuad9kf8n6e6adugmt6lnkg2zzr592r&quot;,
  &quot;scriptPubKey&quot;: &quot;0014a782f4c6e1e75a5b24f3d675d6f11b5ebf3b2142&quot;,
  &quot;ismine&quot;: true,
  &quot;solvable&quot;: true,
  &quot;desc&quot;: &quot;wpkh([d6043800/0'/1'/10']038a2702938e548eaec28feb92c7e4722042cfd1ea16bec9fc274640dc5be05ec5)#zpv26nar&quot;,
  &quot;iswatchonly&quot;: false,
  &quot;isscript&quot;: false,
  &quot;iswitness&quot;: true,
  &quot;witness_version&quot;: 0,
  &quot;witness_program&quot;: &quot;a782f4c6e1e75a5b24f3d675d6f11b5ebf3b2142&quot;,
  &quot;pubkey&quot;: &quot;038a2702938e548eaec28feb92c7e4722042cfd1ea16bec9fc274640dc5be05ec5&quot;,
  &quot;ischange&quot;: true,
  &quot;timestamp&quot;: 1592335137,
  &quot;hdkeypath&quot;: &quot;m/0'/1'/10'&quot;,
  &quot;hdseedid&quot;: &quot;fdea8e2630f00d29a9d6ff2af7bf5b358d061078&quot;,
  &quot;hdmasterfingerprint&quot;: &quot;d6043800&quot;,
  &quot;labels&quot;: [
  ]
}
</code></pre>
<p>Note the <code>ismine</code> results.</p>
<h2 id="send-your-funded-transaction"><a class="header" href="#send-your-funded-transaction">Send Your Funded Transaction</a></h2>
<p>At this point you can sign and send the transaction as usual.</p>
<pre><code>$ signedtx3=$(bitcoin-cli -named signrawtransactionwithwallet hexstring=$rawtxhex3 | jq -r '.hex')
$ bitcoin-cli -named sendrawtransaction hexstring=$signedtx3
8b9dd66c999966462a3d88d6ac9405d09e2aa409c0aa830bdd08dbcbd34a36fa
</code></pre>
<p>In several minutes, you'll have your change back:</p>
<pre><code>$ bitcoin-cli listunspent
[
  {
    &quot;txid&quot;: &quot;8b9dd66c999966462a3d88d6ac9405d09e2aa409c0aa830bdd08dbcbd34a36fa&quot;,
    &quot;vout&quot;: 1,
    &quot;address&quot;: &quot;tb1q57p0f3hpuad9kf8n6e6adugmt6lnkg2zzr592r&quot;,
    &quot;scriptPubKey&quot;: &quot;0014a782f4c6e1e75a5b24f3d675d6f11b5ebf3b2142&quot;,
    &quot;amount&quot;: 0.00007800,
    &quot;confirmations&quot;: 1,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;wpkh([d6043800/0'/1'/10']038a2702938e548eaec28feb92c7e4722042cfd1ea16bec9fc274640dc5be05ec5)#zpv26nar&quot;,
    &quot;safe&quot;: true
  }
]
</code></pre>
<h2 id="summary-sending-coins-with-automated-raw-transactions"><a class="header" href="#summary-sending-coins-with-automated-raw-transactions">Summary: Sending Coins with Automated Raw Transactions</a></h2>
<p>If you must send funds with raw transactions then <code>fundrawtransaction</code> gives you a nice alternative where fees, inputs, and outputs are calculated for you, so you don't accidentally lose a bunch of money.</p>
<blockquote>
<p>:fire: <em><strong>What is the power of sending coins with automated raw transactions?</strong></em></p>
</blockquote>
<blockquote>
<p><em>The advantages.</em> It provides a nice balance. If you're sending funds by hand and <code>sendtoaddress</code> doesn't offer enough control for whatever reason, you can get some of the advantages of raw transactions without the dangers. This methodology should be used whenever possible if you're sending raw transactions by hand.</p>
</blockquote>
<blockquote>
<p><em>The disadvantages.</em> It's a hodge-podge. Though there are a few additional options for the <code>fundrawtransaction</code> command that weren't mentioned here, your control is still limited. You'd probably never want to use this method if you were writing a program where the whole goal is to know exactly what's going on.</p>
</blockquote>
<h2 id="whats-next-16"><a class="header" href="#whats-next-16">What's Next?</a></h2>
<p>Complete your &quot;Sending of Bitcoin Transactions&quot; with <a href="04_6_Creating_a_Segwit_Transaction.html">§4.6: Creating a Segwit Transaction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="46-creating-a-segwit-transaction"><a class="header" href="#46-creating-a-segwit-transaction">4.6: Creating a SegWit Transaction</a></h1>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> This section has been recently added to the course and is an early draft that may still be awaiting review. Caveat reader.</p>
</blockquote>
<p>Once upon a time, the Bitcoin heavens shook with the blocksize wars. Fees were skyrocketing, and users were worried about scaling. The Bitcoin Core developers were reluctant to simply increase the blocksize, but they came upon a compromise: SegWit, the Segregated Witness. Segregated Witness is a fancy way of saying &quot;Separated Signature&quot;. It creates new sorts of transactions that remove signatures to the end of the transaction. By combining this with increased block sizes that only are visible to upgraded nodes, SegWit resolved the scaling problems for Bitcoin at the time (and also resolved a nasty malleability bug that had previously made even better scaling with layer-2 protocols like Lightning impractical). </p>
<p>The catch? SegWit uses different addresses, some of which are compatible with older nodes, and some of which are not.</p>
<blockquote>
<p>:warning: <strong>VERSION WARNING:</strong> SegWit was introduced in BitCoin 0.16.0 with what was described at the time as &quot;full support&quot;. With that said, there were some flaws in its integration with <code>bitcoin-cli</code> at the time which prevented signing from working correctly on new P2SH-SegWit addresses. The non-backward-compatible Bech32 address was also introduced in Bitcoin 0.16.0 and was made the default addresstype in Bitcoin 0.19.0. All of this functionality should now fully work with regard to <code>bitcoin-cli</code> functions (and thus this tutorial). </p>
</blockquote>
<blockquote>
<p>The catch comes in interacting with the wider world. Everyone should be able to send to a P2SH-SegWit address because it was purposefully built to support backward compatibility by wrapping the SegWit functionality in a Bitcoin Script. The same isn't true for Bech32 addresses: if someone tells you that they're unable to send to your Bech32 address, this is why, and you need to generate a <code>legacy</code> or P2SH-SegWit address for their usage. (Many sites, particularly exchanges, can also not generate or receive on SegWit addresses, particularly Bech32 addresses, but that's a whole different issue and doesn't affect your usage of them.)</p>
</blockquote>
<h2 id="understand-a-segwit-transaction"><a class="header" href="#understand-a-segwit-transaction">Understand a SegWit Transaction</a></h2>
<p>In classic transactions, signature (witness) information was stored toward the middle of the transaction, while in SegWit transactions, it's at the bottom. This goes hand-in-hand with the blocksize increases that were introduced in the SegWit upgrade. The blocksize was increased from 1M to a variable amount based on how many SegWit transactions are in a block, starting as low as 1M (no SegWit transactions) and going as high as 4M (all SegWit transactions). This variable size was created to accomodate classic nodes, so that everything remains backward compatible. If a classic node sees a SegWit transaction, it throws out the witness information (resulting in a smaller sized block, under the old 1M limit), while if a new node sees a SegWit transaction, it keeps the witness information (resulting in a larger sized block, up to the new 4M limit).</p>
<p>So that's the what and how of SegWit transactions. Not that you need to know any of it to use them. Most transactions on the Bitcoin network are now SegWit. They're what you're going to natively use for more transactions and receipts of money. The details are no more relevant at this point than the details of how most of Bitcoin works.</p>
<h2 id="create-a-segwit-address"><a class="header" href="#create-a-segwit-address">Create a SegWit Address</a></h2>
<p>You create a SegWit address the same way as any other address, with the <code>getnewaddress</code> and the <code>getrawchangeaddress</code> commands.</p>
<p>If you need to create an address for someone who can't send to the newer Bech32 addresses, then use the <code>p2sh-segwit</code> addresstype:</p>
<pre><code>$ bitcoin-cli -named getnewaddress address_type=p2sh-segwit
2N5h2r4karVqN7uFtpcn8xnA3t5cbpszgyN
</code></pre>
<p>Seeing an address with a &quot;2&quot; prefix means that you did it right.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> &quot;3&quot; for Mainnet.</p>
</blockquote>
<p>However, if the person you're interacting with has a fully mature client, they'll be able to send to a Bech32 address, which you create using the commands in the default way:</p>
<pre><code>$ bitcoin-cli getnewaddress
tb1q5gnwrh7ss5mmqt0qfan85jdagmumnatcscwpk6
</code></pre>
<p>As we've already seen, change addresses generated from within <code>bitcoin-cli</code> interact fine with Bech32 addresses, so there's no point in using the <code>legacy</code> flag there either:</p>
<pre><code>$ bitcoin-cli getrawchangeaddress
tb1q05wx5tyadm8qe83exdqdyqvqqzjt3m38vfu8ff
</code></pre>
<p>Here, note that the unique &quot;tb1&quot; prefix denoted Bech32.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> &quot;bc1&quot; for mainnet.</p>
</blockquote>
<p>Bitcoin-cli doesn't care which address type you're using. You can run a command like <code>listaddressgroupings</code> and it will freely mix addresses of the different types:</p>
<pre><code>$ bitcoin-cli listaddressgroupings
[
  [
    [
      &quot;mfsiRhxbQxcD7HLS4PiAim99oeGyb9QY7m&quot;,
      0.01000000,
      &quot;&quot;
    ]
  ],
  [
    [
      &quot;mi25UrzHnvn3bpEfFCNqJhPWJn5b77a5NE&quot;,
      0.00000000,
      &quot;&quot;
    ],
    [
      &quot;tb1q6dak4e9fz77vsulk89t5z92l2e0zm37yvre4gt&quot;,
      0.00000000
    ]
  ],
  [
    [
      &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
      0.00022000,
      &quot;&quot;
    ]
  ],
  [
    [
      &quot;mk9ry5VVy8mrA8SygxSQQUDNSSXyGFot6h&quot;,
      0.00000000
    ],
    [
      &quot;mqjrdY5raxKzXQf5t2VvVvzhvFAgersu9B&quot;,
      0.00000000
    ],
    [
      &quot;mwJL7cRiW2bUnY81r1thSu3D4jtMmwyU6d&quot;,
      0.00000000,
      &quot;&quot;
    ],
    [
      &quot;tb1q57p0f3hpuad9kf8n6e6adugmt6lnkg2zzr592r&quot;,
      0.00007800
    ]
  ],
  [
    [
      &quot;mpVLL7iqPr4d7BJkEG54mcdm7WmrAhaW6q&quot;,
      0.01000000,
      &quot;&quot;
    ]
  ],
  [
    [
      &quot;tb1q5gnwrh7ss5mmqt0qfan85jdagmumnatcscwpk6&quot;,
      0.01000000,
      &quot;&quot;
    ]
  ]
]
</code></pre>
<h2 id="send-a-segwit-transaction-the-easy-way"><a class="header" href="#send-a-segwit-transaction-the-easy-way">Send a SegWit Transaction The Easy Way</a></h2>
<p>So how do you send a Segwit transaction? Exactly like any other transaction. It doesn't matter if the UTXO is SegWit, the address is SegWit, or some combination thereof. You can expect <code>bitcoin-cli</code> to do the right thing. Though you can tell the differences via the addresses, they don't matter for interacting with things at the <code>bitcoin-cli</code> or RPC level. (And this is one of the advantages of using the command line and the RPC interface, as suggested in this tutorial: experts have already done the hard work for you, including things like how to send to both legacy and Bech32 addresses. You just get to use that functionality to your own advantage.)</p>
<p>Here's an example of sending to a SegWit address, the easy way:</p>
<pre><code>$ bitcoin-cli sendtoaddress tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx 0.005
854a833b667049ac811b4cf1cad40fa7f8dce8b0f4c1018a58b84559b6e05f42
</code></pre>
<p>If you look at your transaction, you can see the use of the Bech32 address:</p>
<pre><code>$ bitcoin-cli -named gettransaction txid=&quot;854a833b667049ac811b4cf1cad40fa7f8dce8b0f4c1018a58b84559b6e05f42&quot; verbose=true
{
  &quot;amount&quot;: -0.00500000,
  &quot;fee&quot;: -0.00036600,
  &quot;confirmations&quot;: 0,
  &quot;trusted&quot;: true,
  &quot;txid&quot;: &quot;854a833b667049ac811b4cf1cad40fa7f8dce8b0f4c1018a58b84559b6e05f42&quot;,
  &quot;walletconflicts&quot;: [
  ],
  &quot;time&quot;: 1592948795,
  &quot;timereceived&quot;: 1592948795,
  &quot;bip125-replaceable&quot;: &quot;no&quot;,
  &quot;details&quot;: [
    {
      &quot;address&quot;: &quot;tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx&quot;,
      &quot;category&quot;: &quot;send&quot;,
      &quot;amount&quot;: -0.00500000,
      &quot;vout&quot;: 1,
      &quot;fee&quot;: -0.00036600,
      &quot;abandoned&quot;: false
    }
  ],
  &quot;hex&quot;: &quot;0200000002114d5a4c3b847bc796b2dc166ca7120607b874aa6904d4a43dd5f9e0ea79d4ba010000006a47304402200a3cc08b9778e7b616340d4cf7841180321d2fa019e43f25e7f710d9a628b55c02200541fc200a07f2eb073ad8554357777d5f1364c5a96afe5e77c6185d66a40fa7012103ee18c598bafc5fbea72d345329803a40ebfcf34014d0e96aac4f504d54e7042dfeffffffa71321e81ef039af490251379143f7247ad91613c26c8f3e3404184218361733000000006a47304402200dd80206b57beb5fa38a3c3578f4b0e40d56d4079116fd2a6fe28e5b8ece72310220298a8c3a1193ea805b27608ff67a2d8b01e347e33a4222edfba499bb1b64a31601210339c001b00dd607eeafd4c117cfcf86be8efbb0ca0a33700cffc0ae0c6ee69d7efeffffff026854160000000000160014d591091b8074a2375ed9985a9c4b18efecfd416520a1070000000000160014751e76e8199196d454941c45d1b3a323f1433bd6c60e1b00&quot;,
  &quot;decoded&quot;: {
    &quot;txid&quot;: &quot;854a833b667049ac811b4cf1cad40fa7f8dce8b0f4c1018a58b84559b6e05f42&quot;,
    &quot;hash&quot;: &quot;854a833b667049ac811b4cf1cad40fa7f8dce8b0f4c1018a58b84559b6e05f42&quot;,
    &quot;version&quot;: 2,
    &quot;size&quot;: 366,
    &quot;vsize&quot;: 366,
    &quot;weight&quot;: 1464,
    &quot;locktime&quot;: 1773254,
    &quot;vin&quot;: [
      {
        &quot;txid&quot;: &quot;bad479eae0f9d53da4d40469aa74b8070612a76c16dcb296c77b843b4c5a4d11&quot;,
        &quot;vout&quot;: 1,
        &quot;scriptSig&quot;: {
          &quot;asm&quot;: &quot;304402200a3cc08b9778e7b616340d4cf7841180321d2fa019e43f25e7f710d9a628b55c02200541fc200a07f2eb073ad8554357777d5f1364c5a96afe5e77c6185d66a40fa7[ALL] 03ee18c598bafc5fbea72d345329803a40ebfcf34014d0e96aac4f504d54e7042d&quot;,
          &quot;hex&quot;: &quot;47304402200a3cc08b9778e7b616340d4cf7841180321d2fa019e43f25e7f710d9a628b55c02200541fc200a07f2eb073ad8554357777d5f1364c5a96afe5e77c6185d66a40fa7012103ee18c598bafc5fbea72d345329803a40ebfcf34014d0e96aac4f504d54e7042d&quot;
        },
        &quot;sequence&quot;: 4294967294
      },
      {
        &quot;txid&quot;: &quot;33173618421804343e8f6cc21316d97a24f7439137510249af39f01ee82113a7&quot;,
        &quot;vout&quot;: 0,
        &quot;scriptSig&quot;: {
          &quot;asm&quot;: &quot;304402200dd80206b57beb5fa38a3c3578f4b0e40d56d4079116fd2a6fe28e5b8ece72310220298a8c3a1193ea805b27608ff67a2d8b01e347e33a4222edfba499bb1b64a316[ALL] 0339c001b00dd607eeafd4c117cfcf86be8efbb0ca0a33700cffc0ae0c6ee69d7e&quot;,
          &quot;hex&quot;: &quot;47304402200dd80206b57beb5fa38a3c3578f4b0e40d56d4079116fd2a6fe28e5b8ece72310220298a8c3a1193ea805b27608ff67a2d8b01e347e33a4222edfba499bb1b64a31601210339c001b00dd607eeafd4c117cfcf86be8efbb0ca0a33700cffc0ae0c6ee69d7e&quot;
        },
        &quot;sequence&quot;: 4294967294
      }
    ],
    &quot;vout&quot;: [
      {
        &quot;value&quot;: 0.01463400,
        &quot;n&quot;: 0,
        &quot;scriptPubKey&quot;: {
          &quot;asm&quot;: &quot;0 d591091b8074a2375ed9985a9c4b18efecfd4165&quot;,
          &quot;hex&quot;: &quot;0014d591091b8074a2375ed9985a9c4b18efecfd4165&quot;,
          &quot;reqSigs&quot;: 1,
          &quot;type&quot;: &quot;witness_v0_keyhash&quot;,
          &quot;addresses&quot;: [
            &quot;tb1q6kgsjxuqwj3rwhkenpdfcjccalk06st9z0k0kh&quot;
          ]
        }
      },
      {
        &quot;value&quot;: 0.00500000,
        &quot;n&quot;: 1,
        &quot;scriptPubKey&quot;: {
          &quot;asm&quot;: &quot;0 751e76e8199196d454941c45d1b3a323f1433bd6&quot;,
          &quot;hex&quot;: &quot;0014751e76e8199196d454941c45d1b3a323f1433bd6&quot;,
          &quot;reqSigs&quot;: 1,
          &quot;type&quot;: &quot;witness_v0_keyhash&quot;,
          &quot;addresses&quot;: [
            &quot;tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx&quot;
          ]
        }
      }
    ]
  }
}
</code></pre>
<p>In fact, both of the <code>vouts</code> use Bech32 addresses: your recipient and the automatically generated change address.</p>
<p>But when we backtrack our <code>vin</code>, we discover that came from a legacy address. Because it doesn't matter:</p>
<pre><code>$ bitcoin-cli -named gettransaction txid=&quot;33173618421804343e8f6cc21316d97a24f7439137510249af39f01ee82113a7&quot;
{
  &quot;amount&quot;: 0.01000000,
  &quot;confirmations&quot;: 43,
  &quot;blockhash&quot;: &quot;00000000000000e2365d2f814d1774b063d9a04356f482010cdfdd537b1a24bb&quot;,
  &quot;blockheight&quot;: 1773212,
  &quot;blockindex&quot;: 103,
  &quot;blocktime&quot;: 1592937103,
  &quot;txid&quot;: &quot;33173618421804343e8f6cc21316d97a24f7439137510249af39f01ee82113a7&quot;,
  &quot;walletconflicts&quot;: [
  ],
  &quot;time&quot;: 1592936845,
  &quot;timereceived&quot;: 1592936845,
  &quot;bip125-replaceable&quot;: &quot;no&quot;,
  &quot;details&quot;: [
    {
      &quot;address&quot;: &quot;mpVLL7iqPr4d7BJkEG54mcdm7WmrAhaW6q&quot;,
      &quot;category&quot;: &quot;receive&quot;,
      &quot;amount&quot;: 0.01000000,
      &quot;label&quot;: &quot;&quot;,
      &quot;vout&quot;: 0
    }
  ],
  &quot;hex&quot;: &quot;020000000001016a66efa334f06e2c54963e48d049a35d7a1bda44633b7464621cae302f35174a0100000017160014f17b16c6404e85165af6f123173e0705ba31ec25feffffff0240420f00000000001976a914626ab1ca41d98f597d18d1ff8151e31a40d4967288acd2125d000000000017a914d5e76abfe5362704ff6bbb000db9cdfa43cd2881870247304402203b3ba83f51c1895b5f639e9bfc40124715e2495ef2c79d4e49c0f8f70fbf2feb02203d50710abe3cf37df4d2a73680dadf3cecbe4f2b5d0b276dbe7711d0c2fa971a012102e64f83ee1c6548bcf44cb965ffdb803f30224459bd2e57a5df97cb41ba476b119b0e1b00&quot;
}
</code></pre>
<h2 id="send-a-segwit-transaction-the-hard-way"><a class="header" href="#send-a-segwit-transaction-the-hard-way">Send a SegWit Transaction The Hard Way</a></h2>
<p>You can similarly fund a transaction with a Bech32 address with no difference to the techniques you've learned so far. Here's an exactly of doing so with a complete raw transaction:</p>
<pre><code>$ changeaddress=$(bitcoin-cli getrawchangeaddress)
$ echo $changeaddress
tb1q4xje3mx9xn7f8khv7p69ekfn0q72kfs8x3ay4j
$ bitcoin-cli listunspent
[
...
  {
    &quot;txid&quot;: &quot;003bfdca5578c0045a76768281f05d5e6f57774be399a76f387e2a0e99e4e452&quot;,
    &quot;vout&quot;: 0,
    &quot;address&quot;: &quot;tb1q5gnwrh7ss5mmqt0qfan85jdagmumnatcscwpk6&quot;,
    &quot;label&quot;: &quot;&quot;,
    &quot;scriptPubKey&quot;: &quot;0014a226e1dfd08537b02de04f667a49bd46f9b9f578&quot;,
    &quot;amount&quot;: 0.01000000,
    &quot;confirmations&quot;: 5,
    &quot;spendable&quot;: true,
    &quot;solvable&quot;: true,
    &quot;desc&quot;: &quot;wpkh([d6043800/0'/0'/5']0327dbe2d58d9ed2dbeca28cd26e18f48aa94c127fa6fb4b60e4188f6360317640)#hd66hknp&quot;,
    &quot;safe&quot;: true
  }
]
$ recipient=tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx
$ utxo_txid=$(bitcoin-cli listunspent | jq -r '.[2] | .txid')
$ utxo_vout=$(bitcoin-cli listunspent | jq -r '.[2] | .vout')
$ echo $utxo_txid $utxo_vout
003bfdca5578c0045a76768281f05d5e6f57774be399a76f387e2a0e99e4e452 0
$ rawtxhex=$(bitcoin-cli -named createrawtransaction inputs='''[ { &quot;txid&quot;: &quot;'$utxo_txid'&quot;, &quot;vout&quot;: '$utxo_vout' } ]''' outputs='''{ &quot;'$recipient'&quot;: 0.002, &quot;'$changeaddress'&quot;: 0.007 }''')
$ signedtx=$(bitcoin-cli -named signrawtransactionwithwallet hexstring=$rawtxhex | jq -r '.hex')
$ bitcoin-cli -named sendrawtransaction hexstring=$signedtx
e02568b706b21bcb56fcf9c4bb7ba63fdbdec1cf2866168c4f50bc0ad693f26c
</code></pre>
<p>It all works exactly the same as other sorts of transactions!</p>
<h3 id="recognize-the-new-descriptor"><a class="header" href="#recognize-the-new-descriptor">Recognize the New Descriptor</a></h3>
<p>If you look at the <code>desc</code> field, you'll note that the SegWit address has a different style descriptor than those encountered in <a href="03_5_Understanding_the_Descriptor.html">§3.5: Understanding the Descriptor</a>. A legacy descriptor described in that section looked like this: <code>pkh([d6043800/0'/0'/18']03efdee34c0009fd175f3b20b5e5a5517fd5d16746f2e635b44617adafeaebc388)#4ahsl9pk</code>. Our new SegWit descriptor instead looks like this: <code>wpkh([d6043800/0'/0'/5']0327dbe2d58d9ed2dbeca28cd26e18f48aa94c127fa6fb4b60e4188f6360317640)#hd66hknp&quot;</code>.</p>
<p>The big thing to note is that function has changed. It was previously <code>pkh</code>, which is a standard P2PKH hashed public-key address. The SegWit address is instead <code>wpkh</code>, which means that it's a P2WPKH native SegWit address. This underlines the :fire: <em><strong>power of descriptors</strong></em>. They describe how to create an address from a key or other information, with the functions unambiguously defining how to make the address based on its type.</p>
<h2 id="summary-creating-a-segwit-transaction"><a class="header" href="#summary-creating-a-segwit-transaction">Summary: Creating a SegWit Transaction</a></h2>
<p>There's really no complexity to creating SegWit transactions. Internally, they're structured differently from legacy transactions, but from the command line there's no difference: you just use an address with a different prefix. The only thing to watch for is that some people may not be able to send to a Bech32 address if they're using obsolete software.</p>
<blockquote>
<p>:fire: <em><strong>What the power of sending coins with SegWit?</strong></em></p>
</blockquote>
<blockquote>
<p><em>The Advantages.</em> SegWit transactions are smaller, and so will be cheaper to send than legacy transactions due to lower fees. Bech32 doubles down on this advantage, and also creates addresses that are harder to foul up when transcribing — and that's pretty important, given that user error is one of the most likely ways to lose your bitcoins.</p>
</blockquote>
<blockquote>
<p><em>The Disadvantages.</em> SegWit addresses may not be supported by obsolete Bitcoin software. In particular, people may not be able to send to your Bech32 address.</p>
</blockquote>
<h2 id="whats-next-17"><a class="header" href="#whats-next-17">What's Next?</a></h2>
<p>Advance through &quot;bitcoin-cli&quot; with <a href="05_0_Controlling_Bitcoin_Transactions.html">Chapter Five: Controlling Bitcoin Transactions</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
